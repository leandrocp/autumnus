<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>cpp - dracula - Autumnus</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'JetBrains Mono', monospace;
            line-height: 1.5;
        }
        pre {
            font-size: 15px;
            margin: 20px;
            padding: 50px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
<pre class="athl" style="color: #f8f8f2; background-color: #282a36;"><code class="language-c++" translate="no" tabindex="0"><span class="athl-line" data-athl-line="1">//////////////////
</span><span class="athl-line" data-athl-line="2">// Comparison to C
</span><span class="athl-line" data-athl-line="3">//////////////////
</span><span class="athl-line" data-athl-line="4">
</span><span class="athl-line" data-athl-line="5">// C++ is almost a superset of C and shares its basic syntax for
</span><span class="athl-line" data-athl-line="6">// variable declarations, primitive types, and functions.
</span><span class="athl-line" data-athl-line="7">
</span><span class="athl-line" data-athl-line="8">// Just like in C, your program&#39;s entry point is a function called
</span><span class="athl-line" data-athl-line="9">// main with an integer return type.
</span><span class="athl-line" data-athl-line="10">// This value serves as the program&#39;s exit status.
</span><span class="athl-line" data-athl-line="11">// See https://en.wikipedia.org/wiki/Exit_status for more information.
</span><span class="athl-line" data-athl-line="12">int <span style="color: #ffb86c;">main</span>(int <span style="color: #ffb86c;">argc</span>, char** <span style="color: #ffb86c;">argv</span>)
</span><span class="athl-line" data-athl-line="13">{
</span><span class="athl-line" data-athl-line="14">    // Command line arguments are passed in by argc and argv in the same way
</span><span class="athl-line" data-athl-line="15">    // they are in C.
</span><span class="athl-line" data-athl-line="16">    // argc indicates the number of arguments,
</span><span class="athl-line" data-athl-line="17">    // and argv is an array of C-style strings (char*)
</span><span class="athl-line" data-athl-line="18">    // representing the arguments.
</span><span class="athl-line" data-athl-line="19">    // The first argument is the name by which the program was called.
</span><span class="athl-line" data-athl-line="20">    // argc and argv can be omitted if you do not care about arguments,
</span><span class="athl-line" data-athl-line="21">    // giving the function signature of int main()
</span><span class="athl-line" data-athl-line="22">
</span><span class="athl-line" data-athl-line="23">    // An exit status of 0 indicates success.
</span><span class="athl-line" data-athl-line="24">    return 0;
</span><span class="athl-line" data-athl-line="25">}
</span><span class="athl-line" data-athl-line="26">
</span><span class="athl-line" data-athl-line="27">// However, C++ varies in some of the following ways:
</span><span class="athl-line" data-athl-line="28">
</span><span class="athl-line" data-athl-line="29">// In C++, character literals are chars, therefore the size is 1
</span><span class="athl-line" data-athl-line="30">sizeof(&#39;c&#39;) == sizeof(char)
</span><span class="athl-line" data-athl-line="31">
</span><span class="athl-line" data-athl-line="32">// In C, character literals are ints, therefore the size is 4
</span><span class="athl-line" data-athl-line="33">sizeof(&#39;c&#39;) == sizeof(int)
</span><span class="athl-line" data-athl-line="34">
</span><span class="athl-line" data-athl-line="35">
</span><span class="athl-line" data-athl-line="36">// C++ has strict prototyping
</span><span class="athl-line" data-athl-line="37">void <span style="color: #8be9fd;">func</span>(); // function which accepts no arguments
</span><span class="athl-line" data-athl-line="38">void <span style="color: #ffb86c;">func</span>(void); // same as earlier
</span><span class="athl-line" data-athl-line="39">
</span><span class="athl-line" data-athl-line="40">// In C
</span><span class="athl-line" data-athl-line="41">void <span style="color: #ffb86c;">func</span>(); // function which may accept any number of arguments with unknown type
</span><span class="athl-line" data-athl-line="42">void <span style="color: #ffb86c;">func</span>(void); // function which accepts no arguments
</span><span class="athl-line" data-athl-line="43">
</span><span class="athl-line" data-athl-line="44">// Use nullptr instead of NULL in C++
</span><span class="athl-line" data-athl-line="45">int* <span style="color: #ffb86c;">ip</span> = <span style="color: #bd93f9;">nullptr</span>;
</span><span class="athl-line" data-athl-line="46">
</span><span class="athl-line" data-athl-line="47">// Most C standard headers are available in C++.
</span><span class="athl-line" data-athl-line="48">// C headers generally end with .h, while
</span><span class="athl-line" data-athl-line="49">// C++ headers are prefixed with &quot;c&quot; and have no &quot;.h&quot; suffix.
</span><span class="athl-line" data-athl-line="50">
</span><span class="athl-line" data-athl-line="51">// The C++ standard version:
</span><span class="athl-line" data-athl-line="52">#include &lt;cstdio&gt;
</span><span class="athl-line" data-athl-line="53">
</span><span class="athl-line" data-athl-line="54">// The C standard version:
</span><span class="athl-line" data-athl-line="55">#include &lt;stdio.h&gt;
</span><span class="athl-line" data-athl-line="56">
</span><span class="athl-line" data-athl-line="57">int <span style="color: #ffb86c;">main</span>()
</span><span class="athl-line" data-athl-line="58">{
</span><span class="athl-line" data-athl-line="59">    <span style="color: #8be9fd;">printf</span>(&quot;Hello, world!\n&quot;);
</span><span class="athl-line" data-athl-line="60">    return 0;
</span><span class="athl-line" data-athl-line="61">}
</span><span class="athl-line" data-athl-line="62">
</span><span class="athl-line" data-athl-line="63">///////////////////////
</span><span class="athl-line" data-athl-line="64">// Function overloading
</span><span class="athl-line" data-athl-line="65">///////////////////////
</span><span class="athl-line" data-athl-line="66">
</span><span class="athl-line" data-athl-line="67">// C++ supports function overloading
</span><span class="athl-line" data-athl-line="68">// provided each function takes different parameters.
</span><span class="athl-line" data-athl-line="69">
</span><span class="athl-line" data-athl-line="70">void <span style="color: #ffb86c;">print</span>(char const* <span style="color: #ffb86c;">myString</span>)
</span><span class="athl-line" data-athl-line="71">{
</span><span class="athl-line" data-athl-line="72">    <span style="color: #8be9fd;">printf</span>(&quot;String %s\n&quot;, <span style="color: #ffb86c;">myString</span>);
</span><span class="athl-line" data-athl-line="73">}
</span><span class="athl-line" data-athl-line="74">
</span><span class="athl-line" data-athl-line="75">void <span style="color: #ffb86c;">print</span>(int <span style="color: #ffb86c;">myInt</span>)
</span><span class="athl-line" data-athl-line="76">{
</span><span class="athl-line" data-athl-line="77">    <span style="color: #8be9fd;">printf</span>(&quot;My int is %d\n&quot;, <span style="color: #ffb86c;">myInt</span>);
</span><span class="athl-line" data-athl-line="78">}
</span><span class="athl-line" data-athl-line="79">
</span><span class="athl-line" data-athl-line="80">int <span style="color: #ffb86c;">main</span>()
</span><span class="athl-line" data-athl-line="81">{
</span><span class="athl-line" data-athl-line="82">    <span style="color: #8be9fd;">print</span>(&quot;Hello&quot;); // Resolves to void print(const char*)
</span><span class="athl-line" data-athl-line="83">    <span style="color: #8be9fd;">print</span>(15); // Resolves to void print(int)
</span><span class="athl-line" data-athl-line="84">}
</span><span class="athl-line" data-athl-line="85">
</span><span class="athl-line" data-athl-line="86">/////////////////////////////
</span><span class="athl-line" data-athl-line="87">// Default function arguments
</span><span class="athl-line" data-athl-line="88">/////////////////////////////
</span><span class="athl-line" data-athl-line="89">
</span><span class="athl-line" data-athl-line="90">// You can provide default arguments for a function
</span><span class="athl-line" data-athl-line="91">// if they are not provided by the caller.
</span><span class="athl-line" data-athl-line="92">
</span><span class="athl-line" data-athl-line="93">void <span style="color: #ffb86c;">doSomethingWithInts</span>(int <span style="color: #ffb86c;">a</span> = 1, int <span style="color: #ffb86c;">b</span> = 4)
</span><span class="athl-line" data-athl-line="94">{
</span><span class="athl-line" data-athl-line="95">    // Do something with the ints here
</span><span class="athl-line" data-athl-line="96">}
</span><span class="athl-line" data-athl-line="97">
</span><span class="athl-line" data-athl-line="98">int <span style="color: #ffb86c;">main</span>()
</span><span class="athl-line" data-athl-line="99">{
</span><span class="athl-line" data-athl-line="100">    <span style="color: #8be9fd;">doSomethingWithInts</span>();      // a = 1,  b = 4
</span><span class="athl-line" data-athl-line="101">    <span style="color: #8be9fd;">doSomethingWithInts</span>(20);    // a = 20, b = 4
</span><span class="athl-line" data-athl-line="102">    <span style="color: #8be9fd;">doSomethingWithInts</span>(20, 5); // a = 20, b = 5
</span><span class="athl-line" data-athl-line="103">}
</span><span class="athl-line" data-athl-line="104">
</span><span class="athl-line" data-athl-line="105">// Default arguments must be at the end of the arguments list.
</span><span class="athl-line" data-athl-line="106">
</span><span class="athl-line" data-athl-line="107">void <span style="color: #ffb86c;">invalidDeclaration</span>(int <span style="color: #ffb86c;">a</span> = 1, int <span style="color: #ffb86c;">b</span>) // Error!
</span><span class="athl-line" data-athl-line="108">{
</span><span class="athl-line" data-athl-line="109">}
</span><span class="athl-line" data-athl-line="110">
</span><span class="athl-line" data-athl-line="111">
</span><span class="athl-line" data-athl-line="112">/////////////
</span><span class="athl-line" data-athl-line="113">// Namespaces
</span><span class="athl-line" data-athl-line="114">/////////////
</span><span class="athl-line" data-athl-line="115">
</span><span class="athl-line" data-athl-line="116">// Namespaces provide separate scopes for variable, function,
</span><span class="athl-line" data-athl-line="117">// and other declarations.
</span><span class="athl-line" data-athl-line="118">// Namespaces can be nested.
</span><span class="athl-line" data-athl-line="119">
</span><span class="athl-line" data-athl-line="120"><span style="color: #ff79c6;">namespace</span> <span style="color: #a4ffff;">First</span> {
</span><span class="athl-line" data-athl-line="121">    <span style="color: #ff79c6;">namespace</span> <span style="color: #a4ffff;">Nested</span> {
</span><span class="athl-line" data-athl-line="122">        void <span style="color: #ffb86c;">foo</span>()
</span><span class="athl-line" data-athl-line="123">        {
</span><span class="athl-line" data-athl-line="124">            <span style="color: #8be9fd;">printf</span>(&quot;This is First::Nested::foo\n&quot;);
</span><span class="athl-line" data-athl-line="125">        }
</span><span class="athl-line" data-athl-line="126">    } // end namespace Nested
</span><span class="athl-line" data-athl-line="127">} // end namespace First
</span><span class="athl-line" data-athl-line="128">
</span><span class="athl-line" data-athl-line="129"><span style="color: #ff79c6;">namespace</span> <span style="color: #a4ffff;">Second</span> {
</span><span class="athl-line" data-athl-line="130">    void <span style="color: #ffb86c;">foo</span>()
</span><span class="athl-line" data-athl-line="131">    {
</span><span class="athl-line" data-athl-line="132">        <span style="color: #8be9fd;">printf</span>(&quot;This is Second::foo\n&quot;);
</span><span class="athl-line" data-athl-line="133">    }
</span><span class="athl-line" data-athl-line="134">    void <span style="color: #ffb86c;">bar</span>()
</span><span class="athl-line" data-athl-line="135">    {
</span><span class="athl-line" data-athl-line="136">        <span style="color: #8be9fd;">printf</span>(&quot;This is Second::bar\n&quot;);
</span><span class="athl-line" data-athl-line="137">    }
</span><span class="athl-line" data-athl-line="138">}
</span><span class="athl-line" data-athl-line="139">
</span><span class="athl-line" data-athl-line="140">void <span style="color: #ffb86c;">foo</span>()
</span><span class="athl-line" data-athl-line="141">{
</span><span class="athl-line" data-athl-line="142">    <span style="color: #8be9fd;">printf</span>(&quot;This is global foo\n&quot;);
</span><span class="athl-line" data-athl-line="143">}
</span><span class="athl-line" data-athl-line="144">
</span><span class="athl-line" data-athl-line="145">int <span style="color: #ffb86c;">main</span>()
</span><span class="athl-line" data-athl-line="146">{
</span><span class="athl-line" data-athl-line="147">    // Includes all symbols from namespace Second into the current scope. Note
</span><span class="athl-line" data-athl-line="148">    // that while bar() works, simply using foo() no longer works, since it is
</span><span class="athl-line" data-athl-line="149">    // now ambiguous whether we&#39;re calling the foo in namespace Second or the
</span><span class="athl-line" data-athl-line="150">    // top level.
</span><span class="athl-line" data-athl-line="151">    <span style="color: #ff79c6;">using</span> <span style="color: #ff79c6;">namespace</span> <span style="color: #ffb86c;">Second</span>;
</span><span class="athl-line" data-athl-line="152">
</span><span class="athl-line" data-athl-line="153">    <span style="color: #8be9fd;">bar</span>(); // prints &quot;This is Second::bar&quot;
</span><span class="athl-line" data-athl-line="154">    <span style="color: #a4ffff;">Second</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">foo</span>(); // prints &quot;This is Second::foo&quot;
</span><span class="athl-line" data-athl-line="155">    <span style="color: #a4ffff;">First</span><span style="color: #f8f8f2;">::</span><span style="color: #a4ffff;">Nested</span><span style="color: #f8f8f2;">::</span><span style="color: #50fa7b;">foo</span>(); // prints &quot;This is First::Nested::foo&quot;
</span><span class="athl-line" data-athl-line="156">    <span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">foo</span>(); // prints &quot;This is global foo&quot;
</span><span class="athl-line" data-athl-line="157">}
</span><span class="athl-line" data-athl-line="158">
</span><span class="athl-line" data-athl-line="159">///////////////
</span><span class="athl-line" data-athl-line="160">// Input/Output
</span><span class="athl-line" data-athl-line="161">///////////////
</span><span class="athl-line" data-athl-line="162">
</span><span class="athl-line" data-athl-line="163">// C++ input and output uses streams
</span><span class="athl-line" data-athl-line="164">// cin, cout, and cerr represent stdin, stdout, and stderr.
</span><span class="athl-line" data-athl-line="165">// &lt;&lt; is the insertion operator and &gt;&gt; is the extraction operator.
</span><span class="athl-line" data-athl-line="166">
</span><span class="athl-line" data-athl-line="167">#include &lt;iostream&gt; // Include for I/O streams
</span><span class="athl-line" data-athl-line="168">
</span><span class="athl-line" data-athl-line="169">int <span style="color: #ffb86c;">main</span>()
</span><span class="athl-line" data-athl-line="170">{
</span><span class="athl-line" data-athl-line="171">    int <span style="color: #ffb86c;">myInt</span>;
</span><span class="athl-line" data-athl-line="172">
</span><span class="athl-line" data-athl-line="173">    // Prints to stdout (or terminal/screen)
</span><span class="athl-line" data-athl-line="174">    // std::cout referring the access to the std namespace
</span><span class="athl-line" data-athl-line="175">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Enter your favorite number:\n&quot;;
</span><span class="athl-line" data-athl-line="176">    // Takes in input
</span><span class="athl-line" data-athl-line="177">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cin</span> &gt;&gt; <span style="color: #ffb86c;">myInt</span>;
</span><span class="athl-line" data-athl-line="178">
</span><span class="athl-line" data-athl-line="179">    // cout can also be formatted
</span><span class="athl-line" data-athl-line="180">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Your favorite number is &quot; &lt;&lt; <span style="color: #ffb86c;">myInt</span> &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="181">    // prints &quot;Your favorite number is &lt;myInt&gt;&quot;
</span><span class="athl-line" data-athl-line="182">
</span><span class="athl-line" data-athl-line="183">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cerr</span> &lt;&lt; &quot;Used for error messages&quot;;
</span><span class="athl-line" data-athl-line="184">
</span><span class="athl-line" data-athl-line="185">    // flush string stream buffer with new line
</span><span class="athl-line" data-athl-line="186">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;I flushed it away&quot; &lt;&lt; <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">endl</span>;
</span><span class="athl-line" data-athl-line="187">}
</span><span class="athl-line" data-athl-line="188">
</span><span class="athl-line" data-athl-line="189">//////////
</span><span class="athl-line" data-athl-line="190">// Strings
</span><span class="athl-line" data-athl-line="191">//////////
</span><span class="athl-line" data-athl-line="192">
</span><span class="athl-line" data-athl-line="193">// Strings in C++ are objects and have many member functions
</span><span class="athl-line" data-athl-line="194">#include &lt;string&gt;
</span><span class="athl-line" data-athl-line="195">
</span><span class="athl-line" data-athl-line="196"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">myString</span> = &quot;Hello&quot;;
</span><span class="athl-line" data-athl-line="197"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">myOtherString</span> = &quot; World&quot;;
</span><span class="athl-line" data-athl-line="198">
</span><span class="athl-line" data-athl-line="199">// + is used for concatenation.
</span><span class="athl-line" data-athl-line="200"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">myString</span> + <span style="color: #ffb86c;">myOtherString</span>; // &quot;Hello World&quot;
</span><span class="athl-line" data-athl-line="201">
</span><span class="athl-line" data-athl-line="202"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">myString</span> + &quot; You&quot;; // &quot;Hello You&quot;
</span><span class="athl-line" data-athl-line="203">
</span><span class="athl-line" data-athl-line="204">// C++ string length can be found from either string::length() or string::size()
</span><span class="athl-line" data-athl-line="205"><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">myString</span>.<span style="color: #8be9fd;">length</span>() + <span style="color: #ffb86c;">myOtherString</span>.<span style="color: #8be9fd;">size</span>(); // Outputs 11 (= 5 + 6).
</span><span class="athl-line" data-athl-line="206">
</span><span class="athl-line" data-athl-line="207">// C++ strings are mutable.
</span><span class="athl-line" data-athl-line="208"><span style="color: #ffb86c;">myString</span>.<span style="color: #8be9fd;">append</span>(&quot; Dog&quot;);
</span><span class="athl-line" data-athl-line="209"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">myString</span>; // &quot;Hello Dog&quot;
</span><span class="athl-line" data-athl-line="210">
</span><span class="athl-line" data-athl-line="211">// C++ can handle C-style strings with related functions using cstrings
</span><span class="athl-line" data-athl-line="212">#include &lt;cstring&gt;
</span><span class="athl-line" data-athl-line="213">
</span><span class="athl-line" data-athl-line="214">char <span style="color: #ffb86c;">myOldString</span>[10] = &quot;Hello CPP&quot;;
</span><span class="athl-line" data-athl-line="215"><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">myOldString</span>;
</span><span class="athl-line" data-athl-line="216"><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Length = &quot; &lt;&lt; <span style="color: #8be9fd;">strlen</span>(<span style="color: #ffb86c;">myOldString</span>); // Length = 9
</span><span class="athl-line" data-athl-line="217">
</span><span class="athl-line" data-athl-line="218">/////////////
</span><span class="athl-line" data-athl-line="219">// References
</span><span class="athl-line" data-athl-line="220">/////////////
</span><span class="athl-line" data-athl-line="221">
</span><span class="athl-line" data-athl-line="222">// In addition to pointers like the ones in C,
</span><span class="athl-line" data-athl-line="223">// C++ has _references_.
</span><span class="athl-line" data-athl-line="224">// These are pointer types that cannot be reassigned once set
</span><span class="athl-line" data-athl-line="225">// and cannot be null.
</span><span class="athl-line" data-athl-line="226">// They also have the same syntax as the variable itself:
</span><span class="athl-line" data-athl-line="227">// No * is needed for dereferencing and
</span><span class="athl-line" data-athl-line="228">// &amp; (address of) is not used for assignment.
</span><span class="athl-line" data-athl-line="229">
</span><span class="athl-line" data-athl-line="230"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">foo</span> = &quot;I am foo&quot;;
</span><span class="athl-line" data-athl-line="231"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">bar</span> = &quot;I am bar&quot;;
</span><span class="athl-line" data-athl-line="232">
</span><span class="athl-line" data-athl-line="233"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string&amp; <span style="color: #ffb86c;">fooRef</span> = <span style="color: #ffb86c;">foo</span>; // This creates a reference to foo.
</span><span class="athl-line" data-athl-line="234"><span style="color: #ffb86c;">fooRef</span> += &quot;. Hi!&quot;; // Modifies foo through the reference
</span><span class="athl-line" data-athl-line="235"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">fooRef</span>; // Prints &quot;I am foo. Hi!&quot;
</span><span class="athl-line" data-athl-line="236">
</span><span class="athl-line" data-athl-line="237"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &amp;<span style="color: #ffb86c;">fooRef</span> &lt;&lt; &#39;\n&#39;; // Prints the address of foo
</span><span class="athl-line" data-athl-line="238">// Doesn&#39;t reassign &quot;fooRef&quot;. This is the same as &quot;foo = bar&quot;, and
</span><span class="athl-line" data-athl-line="239">//   foo == &quot;I am bar&quot;
</span><span class="athl-line" data-athl-line="240">// after this line.
</span><span class="athl-line" data-athl-line="241"><span style="color: #ffb86c;">fooRef</span> = <span style="color: #ffb86c;">bar</span>;
</span><span class="athl-line" data-athl-line="242"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &amp;<span style="color: #ffb86c;">fooRef</span> &lt;&lt; &#39;\n&#39;; // Still prints the address of foo
</span><span class="athl-line" data-athl-line="243"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">fooRef</span> &lt;&lt; &#39;\n&#39;;  // Prints &quot;I am bar&quot;
</span><span class="athl-line" data-athl-line="244">
</span><span class="athl-line" data-athl-line="245">// The address of fooRef remains the same, i.e. it is still referring to foo.
</span><span class="athl-line" data-athl-line="246">
</span><span class="athl-line" data-athl-line="247">
</span><span class="athl-line" data-athl-line="248">const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string&amp; <span style="color: #ffb86c;">barRef</span> = <span style="color: #ffb86c;">bar</span>; // Create a const reference to bar.
</span><span class="athl-line" data-athl-line="249">// Like C, const values (and pointers and references) cannot be modified.
</span><span class="athl-line" data-athl-line="250"><span style="color: #ffb86c;">barRef</span> += &quot;. Hi!&quot;; // Error, const references cannot be modified.
</span><span class="athl-line" data-athl-line="251">
</span><span class="athl-line" data-athl-line="252">// Sidetrack: Before we talk more about references, we must introduce a concept
</span><span class="athl-line" data-athl-line="253">// called a temporary object. Suppose we have the following code:
</span><span class="athl-line" data-athl-line="254"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">tempObjectFun</span>() { ... }
</span><span class="athl-line" data-athl-line="255"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">retVal</span> = <span style="color: #8be9fd;">tempObjectFun</span>();
</span><span class="athl-line" data-athl-line="256">
</span><span class="athl-line" data-athl-line="257">// What happens in the second line is actually:
</span><span class="athl-line" data-athl-line="258">//   - a string object is returned from tempObjectFun
</span><span class="athl-line" data-athl-line="259">//   - a new string is constructed with the returned object as argument to the
</span><span class="athl-line" data-athl-line="260">//     constructor
</span><span class="athl-line" data-athl-line="261">//   - the returned object is destroyed
</span><span class="athl-line" data-athl-line="262">// The returned object is called a temporary object. Temporary objects are
</span><span class="athl-line" data-athl-line="263">// created whenever a function returns an object, and they are destroyed at the
</span><span class="athl-line" data-athl-line="264">// end of the evaluation of the enclosing expression (Well, this is what the
</span><span class="athl-line" data-athl-line="265">// standard says, but compilers are allowed to change this behavior. Look up
</span><span class="athl-line" data-athl-line="266">// &quot;return value optimization&quot; if you&#39;re into these kinds of details). So in
</span><span class="athl-line" data-athl-line="267">// this code:
</span><span class="athl-line" data-athl-line="268">foo(<span style="color: #ffb86c;">bar</span>(tempObjectFun()))
</span><span class="athl-line" data-athl-line="269">
</span><span class="athl-line" data-athl-line="270">// assuming foo and bar exist, the object returned from tempObjectFun is
</span><span class="athl-line" data-athl-line="271">// passed to bar, and it is destroyed before foo is called.
</span><span class="athl-line" data-athl-line="272">
</span><span class="athl-line" data-athl-line="273">// Now back to references. The exception to the &quot;at the end of the enclosing
</span><span class="athl-line" data-athl-line="274">// expression&quot; rule is if a temporary object is bound to a const reference, in
</span><span class="athl-line" data-athl-line="275">// which case its life gets extended to the current scope:
</span><span class="athl-line" data-athl-line="276">
</span><span class="athl-line" data-athl-line="277">void <span style="color: #ffb86c;">constReferenceTempObjectFun</span>() {
</span><span class="athl-line" data-athl-line="278">    // constRef gets the temporary object, and it is valid until the end of this
</span><span class="athl-line" data-athl-line="279">    // function.
</span><span class="athl-line" data-athl-line="280">    const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string&amp; <span style="color: #ffb86c;">constRef</span> = <span style="color: #8be9fd;">tempObjectFun</span>();
</span><span class="athl-line" data-athl-line="281">    ...
</span><span class="athl-line" data-athl-line="282">}
</span><span class="athl-line" data-athl-line="283">
</span><span class="athl-line" data-athl-line="284">// Another kind of reference introduced in C++11 is specifically for temporary
</span><span class="athl-line" data-athl-line="285">// objects. You cannot have a variable of its type, but it takes precedence in
</span><span class="athl-line" data-athl-line="286">// overload resolution:
</span><span class="athl-line" data-athl-line="287">
</span><span class="athl-line" data-athl-line="288">void <span style="color: #ffb86c;">someFun</span>(<span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">s</span></span>) { ... }  // Regular reference
</span><span class="athl-line" data-athl-line="289">void <span style="color: #ffb86c;">someFun</span>(<span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp;&amp; <span style="color: #ffb86c;">s</span></span>) { ... }  // Reference to temporary object
</span><span class="athl-line" data-athl-line="290">
</span><span class="athl-line" data-athl-line="291"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">foo</span>;
</span><span class="athl-line" data-athl-line="292"><span style="color: #8be9fd;">someFun</span>(<span style="color: #ffb86c;">foo</span>);  // Calls the version with regular reference
</span><span class="athl-line" data-athl-line="293"><span style="color: #8be9fd;">someFun</span>(<span style="color: #8be9fd;">tempObjectFun</span>());  // Calls the version with temporary reference
</span><span class="athl-line" data-athl-line="294">
</span><span class="athl-line" data-athl-line="295">// For example, you will see these two versions of constructors for
</span><span class="athl-line" data-athl-line="296">// std::basic_string:
</span><span class="athl-line" data-athl-line="297"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">basic_string</span>(const basic_string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">other</span></span>);
</span><span class="athl-line" data-athl-line="298"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">basic_string</span>(<span style="color: #ffb86c;">basic_string</span>&amp;&amp; <span style="color: #ffb86c;">other</span>);
</span><span class="athl-line" data-athl-line="299">
</span><span class="athl-line" data-athl-line="300">// Idea being if we are constructing a new string from a temporary object (which
</span><span class="athl-line" data-athl-line="301">// is going to be destroyed soon anyway), we can have a more efficient
</span><span class="athl-line" data-athl-line="302">// constructor that &quot;salvages&quot; parts of that temporary string. You will see this
</span><span class="athl-line" data-athl-line="303">// concept referred to as &quot;move semantics&quot;.
</span><span class="athl-line" data-athl-line="304">
</span><span class="athl-line" data-athl-line="305">/////////////////////
</span><span class="athl-line" data-athl-line="306">// Enums
</span><span class="athl-line" data-athl-line="307">/////////////////////
</span><span class="athl-line" data-athl-line="308">
</span><span class="athl-line" data-athl-line="309">// Enums are a way to assign a value to a constant most commonly used for
</span><span class="athl-line" data-athl-line="310">// easier visualization and reading of code
</span><span class="athl-line" data-athl-line="311">enum ECarTypes
</span><span class="athl-line" data-athl-line="312">{
</span><span class="athl-line" data-athl-line="313">    <span style="color: #ffb86c;">Sedan</span>,
</span><span class="athl-line" data-athl-line="314">    <span style="color: #ffb86c;">Hatchback</span>,
</span><span class="athl-line" data-athl-line="315">    <span style="color: #ffb86c;">SUV</span>,
</span><span class="athl-line" data-athl-line="316">    <span style="color: #ffb86c;">Wagon</span>
</span><span class="athl-line" data-athl-line="317">};
</span><span class="athl-line" data-athl-line="318">
</span><span class="athl-line" data-athl-line="319">ECarTypes <span style="color: #ffb86c;">GetPreferredCarType</span>()
</span><span class="athl-line" data-athl-line="320">{
</span><span class="athl-line" data-athl-line="321">    return <span style="color: #a4ffff;">ECarTypes</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">Hatchback</span>;
</span><span class="athl-line" data-athl-line="322">}
</span><span class="athl-line" data-athl-line="323">
</span><span class="athl-line" data-athl-line="324">// As of C++11 there is an easy way to assign a type to the enum which can be
</span><span class="athl-line" data-athl-line="325">// useful in serialization of data and converting enums back-and-forth between
</span><span class="athl-line" data-athl-line="326">// the desired type and their respective constants
</span><span class="athl-line" data-athl-line="327">enum ECarTypes : uint8_t
</span><span class="athl-line" data-athl-line="328">{
</span><span class="athl-line" data-athl-line="329">    <span style="color: #ffb86c;">Sedan</span>, // 0
</span><span class="athl-line" data-athl-line="330">    <span style="color: #ffb86c;">Hatchback</span>, // 1
</span><span class="athl-line" data-athl-line="331">    <span style="color: #ffb86c;">SUV</span> = 254, // 254
</span><span class="athl-line" data-athl-line="332">    <span style="color: #ffb86c;">Hybrid</span> // 255
</span><span class="athl-line" data-athl-line="333">};
</span><span class="athl-line" data-athl-line="334">
</span><span class="athl-line" data-athl-line="335">void <span style="color: #ffb86c;">WriteByteToFile</span>(uint8_t <span style="color: #ffb86c;">InputValue</span>)
</span><span class="athl-line" data-athl-line="336">{
</span><span class="athl-line" data-athl-line="337">    // Serialize the InputValue to a file
</span><span class="athl-line" data-athl-line="338">}
</span><span class="athl-line" data-athl-line="339">
</span><span class="athl-line" data-athl-line="340">void <span style="color: #ffb86c;">WritePreferredCarTypeToFile</span>(ECarTypes <span style="color: #ffb86c;">InputCarType</span>)
</span><span class="athl-line" data-athl-line="341">{
</span><span class="athl-line" data-athl-line="342">    // The enum is implicitly converted to a uint8_t due to its declared enum type
</span><span class="athl-line" data-athl-line="343">    <span style="color: #8be9fd;">WriteByteToFile</span>(<span style="color: #ffb86c;">InputCarType</span>);
</span><span class="athl-line" data-athl-line="344">}
</span><span class="athl-line" data-athl-line="345">
</span><span class="athl-line" data-athl-line="346">// On the other hand you may not want enums to be accidentally cast to an integer
</span><span class="athl-line" data-athl-line="347">// type or to other enums so it is instead possible to create an enum class which
</span><span class="athl-line" data-athl-line="348">// won&#39;t be implicitly converted
</span><span class="athl-line" data-athl-line="349">enum <span style="color: #ff79c6;">class</span> ECarTypes : uint8_t
</span><span class="athl-line" data-athl-line="350">{
</span><span class="athl-line" data-athl-line="351">    <span style="color: #ffb86c;">Sedan</span>, // 0
</span><span class="athl-line" data-athl-line="352">    <span style="color: #ffb86c;">Hatchback</span>, // 1
</span><span class="athl-line" data-athl-line="353">    <span style="color: #ffb86c;">SUV</span> = 254, // 254
</span><span class="athl-line" data-athl-line="354">    <span style="color: #ffb86c;">Hybrid</span> // 255
</span><span class="athl-line" data-athl-line="355">};
</span><span class="athl-line" data-athl-line="356">
</span><span class="athl-line" data-athl-line="357">void <span style="color: #ffb86c;">WriteByteToFile</span>(uint8_t <span style="color: #ffb86c;">InputValue</span>)
</span><span class="athl-line" data-athl-line="358">{
</span><span class="athl-line" data-athl-line="359">    // Serialize the InputValue to a file
</span><span class="athl-line" data-athl-line="360">}
</span><span class="athl-line" data-athl-line="361">
</span><span class="athl-line" data-athl-line="362">void <span style="color: #ffb86c;">WritePreferredCarTypeToFile</span>(ECarTypes <span style="color: #ffb86c;">InputCarType</span>)
</span><span class="athl-line" data-athl-line="363">{
</span><span class="athl-line" data-athl-line="364">    // Won&#39;t compile even though ECarTypes is a uint8_t due to the enum
</span><span class="athl-line" data-athl-line="365">    // being declared as an &quot;enum class&quot;!
</span><span class="athl-line" data-athl-line="366">    <span style="color: #8be9fd;">WriteByteToFile</span>(<span style="color: #ffb86c;">InputCarType</span>);
</span><span class="athl-line" data-athl-line="367">}
</span><span class="athl-line" data-athl-line="368">
</span><span class="athl-line" data-athl-line="369">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="370">// Classes and object-oriented programming
</span><span class="athl-line" data-athl-line="371">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="372">
</span><span class="athl-line" data-athl-line="373">// First example of classes
</span><span class="athl-line" data-athl-line="374">#include &lt;iostream&gt;
</span><span class="athl-line" data-athl-line="375">
</span><span class="athl-line" data-athl-line="376">// Declare a class.
</span><span class="athl-line" data-athl-line="377">// Classes are usually declared in header (.h or .hpp) files.
</span><span class="athl-line" data-athl-line="378"><span style="color: #ff79c6;">class</span> Dog {
</span><span class="athl-line" data-athl-line="379">    // Member variables and functions are private by default.
</span><span class="athl-line" data-athl-line="380">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">name</span>;
</span><span class="athl-line" data-athl-line="381">    int <span style="color: #ffb86c;">weight</span>;
</span><span class="athl-line" data-athl-line="382">
</span><span class="athl-line" data-athl-line="383">// All members following this are public
</span><span class="athl-line" data-athl-line="384">// until &quot;private:&quot; or &quot;protected:&quot; is found.
</span><span class="athl-line" data-athl-line="385"><span style="color: #ff79c6;">public</span>:
</span><span class="athl-line" data-athl-line="386">
</span><span class="athl-line" data-athl-line="387">    // Default constructor
</span><span class="athl-line" data-athl-line="388">    <span style="color: #ffb86c;">Dog</span>();
</span><span class="athl-line" data-athl-line="389">
</span><span class="athl-line" data-athl-line="390">    // Member function declarations (implementations to follow)
</span><span class="athl-line" data-athl-line="391">    // Note that we use std::string here instead of placing
</span><span class="athl-line" data-athl-line="392">    // using namespace std;
</span><span class="athl-line" data-athl-line="393">    // above.
</span><span class="athl-line" data-athl-line="394">    // Never put a &quot;using namespace&quot; statement in a header.
</span><span class="athl-line" data-athl-line="395">    void <span style="color: #50fa7b;">setName</span>(const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">dogsName</span></span>);
</span><span class="athl-line" data-athl-line="396">
</span><span class="athl-line" data-athl-line="397">    void <span style="color: #50fa7b;">setWeight</span>(int <span style="color: #ffb86c;">dogsWeight</span>);
</span><span class="athl-line" data-athl-line="398">
</span><span class="athl-line" data-athl-line="399">    // Functions that do not modify the state of the object
</span><span class="athl-line" data-athl-line="400">    // should be marked as const.
</span><span class="athl-line" data-athl-line="401">    // This allows you to call them if given a const reference to the object.
</span><span class="athl-line" data-athl-line="402">    // Also note the functions must be explicitly declared as _virtual_
</span><span class="athl-line" data-athl-line="403">    // in order to be overridden in derived classes.
</span><span class="athl-line" data-athl-line="404">    // Functions are not virtual by default for performance reasons.
</span><span class="athl-line" data-athl-line="405">    <span style="color: #ff79c6;">virtual</span> void <span style="color: #50fa7b;">print</span>() const;
</span><span class="athl-line" data-athl-line="406">
</span><span class="athl-line" data-athl-line="407">    // Functions can also be defined inside the class body.
</span><span class="athl-line" data-athl-line="408">    // Functions defined as such are automatically inlined.
</span><span class="athl-line" data-athl-line="409">    void <span style="color: #50fa7b;">bark</span>() const { <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">name</span> &lt;&lt; &quot; barks!\n&quot;; }
</span><span class="athl-line" data-athl-line="410">
</span><span class="athl-line" data-athl-line="411">    // Along with constructors, C++ provides destructors.
</span><span class="athl-line" data-athl-line="412">    // These are called when an object is deleted or falls out of scope.
</span><span class="athl-line" data-athl-line="413">    // This enables powerful paradigms such as RAII
</span><span class="athl-line" data-athl-line="414">    // (see below)
</span><span class="athl-line" data-athl-line="415">    // The destructor should be virtual if a class is to be derived from;
</span><span class="athl-line" data-athl-line="416">    // if it is not virtual, then the derived class&#39; destructor will
</span><span class="athl-line" data-athl-line="417">    // not be called if the object is destroyed through a base-class reference
</span><span class="athl-line" data-athl-line="418">    // or pointer.
</span><span class="athl-line" data-athl-line="419">    <span style="color: #ff79c6;">virtual</span> ~<span style="color: #50fa7b;">Dog</span>();
</span><span class="athl-line" data-athl-line="420">
</span><span class="athl-line" data-athl-line="421">}; // A semicolon must follow the class definition.
</span><span class="athl-line" data-athl-line="422">
</span><span class="athl-line" data-athl-line="423">// Class member functions are usually implemented in .cpp files.
</span><span class="athl-line" data-athl-line="424"><span style="color: #a4ffff;">Dog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">Dog</span>()
</span><span class="athl-line" data-athl-line="425">{
</span><span class="athl-line" data-athl-line="426">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;A dog has been constructed\n&quot;;
</span><span class="athl-line" data-athl-line="427">}
</span><span class="athl-line" data-athl-line="428">
</span><span class="athl-line" data-athl-line="429">// Objects (such as strings) should be passed by reference
</span><span class="athl-line" data-athl-line="430">// if you are modifying them or const reference if you are not.
</span><span class="athl-line" data-athl-line="431">void <span style="color: #a4ffff;">Dog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">setName</span>(const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">dogsName</span></span>)
</span><span class="athl-line" data-athl-line="432">{
</span><span class="athl-line" data-athl-line="433">    <span style="color: #ffb86c;">name</span> = <span style="color: #ffb86c;">dogsName</span>;
</span><span class="athl-line" data-athl-line="434">}
</span><span class="athl-line" data-athl-line="435">
</span><span class="athl-line" data-athl-line="436">void <span style="color: #a4ffff;">Dog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">setWeight</span>(int <span style="color: #ffb86c;">dogsWeight</span>)
</span><span class="athl-line" data-athl-line="437">{
</span><span class="athl-line" data-athl-line="438">    <span style="color: #ffb86c;">weight</span> = <span style="color: #ffb86c;">dogsWeight</span>;
</span><span class="athl-line" data-athl-line="439">}
</span><span class="athl-line" data-athl-line="440">
</span><span class="athl-line" data-athl-line="441">// Notice that &quot;virtual&quot; is only needed in the declaration, not the definition.
</span><span class="athl-line" data-athl-line="442">void <span style="color: #a4ffff;">Dog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">print</span>() const
</span><span class="athl-line" data-athl-line="443">{
</span><span class="athl-line" data-athl-line="444">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Dog is &quot; &lt;&lt; <span style="color: #ffb86c;">name</span> &lt;&lt; &quot; and weighs &quot; &lt;&lt; <span style="color: #ffb86c;">weight</span> &lt;&lt; &quot;kg\n&quot;;
</span><span class="athl-line" data-athl-line="445">}
</span><span class="athl-line" data-athl-line="446">
</span><span class="athl-line" data-athl-line="447"><span style="color: #a4ffff;">Dog</span><span style="color: #f8f8f2;">::</span>~<span style="color: #50fa7b;">Dog</span>()
</span><span class="athl-line" data-athl-line="448">{
</span><span class="athl-line" data-athl-line="449">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Goodbye &quot; &lt;&lt; <span style="color: #ffb86c;">name</span> &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="450">}
</span><span class="athl-line" data-athl-line="451">
</span><span class="athl-line" data-athl-line="452">int <span style="color: #ffb86c;">main</span>() {
</span><span class="athl-line" data-athl-line="453">    Dog <span style="color: #ffb86c;">myDog</span>; // prints &quot;A dog has been constructed&quot;
</span><span class="athl-line" data-athl-line="454">    <span style="color: #ffb86c;">myDog</span>.<span style="color: #8be9fd;">setName</span>(&quot;Barkley&quot;);
</span><span class="athl-line" data-athl-line="455">    <span style="color: #ffb86c;">myDog</span>.<span style="color: #8be9fd;">setWeight</span>(10);
</span><span class="athl-line" data-athl-line="456">    <span style="color: #ffb86c;">myDog</span>.<span style="color: #8be9fd;">print</span>(); // prints &quot;Dog is Barkley and weighs 10 kg&quot;
</span><span class="athl-line" data-athl-line="457">    return 0;
</span><span class="athl-line" data-athl-line="458">} // prints &quot;Goodbye Barkley&quot;
</span><span class="athl-line" data-athl-line="459">
</span><span class="athl-line" data-athl-line="460">// Inheritance:
</span><span class="athl-line" data-athl-line="461">
</span><span class="athl-line" data-athl-line="462">// This class inherits everything public and protected from the Dog class
</span><span class="athl-line" data-athl-line="463">// as well as private but may not directly access private members/methods
</span><span class="athl-line" data-athl-line="464">// without a public or protected method for doing so
</span><span class="athl-line" data-athl-line="465"><span style="color: #ff79c6;">class</span> OwnedDog : <span style="color: #ff79c6;">public</span> Dog {
</span><span class="athl-line" data-athl-line="466">
</span><span class="athl-line" data-athl-line="467"><span style="color: #ff79c6;">public</span>:
</span><span class="athl-line" data-athl-line="468">    void <span style="color: #50fa7b;">setOwner</span>(const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">dogsOwner</span></span>);
</span><span class="athl-line" data-athl-line="469">
</span><span class="athl-line" data-athl-line="470">    // Override the behavior of the print function for all OwnedDogs. See
</span><span class="athl-line" data-athl-line="471">    // https://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping
</span><span class="athl-line" data-athl-line="472">    // for a more general introduction if you are unfamiliar with
</span><span class="athl-line" data-athl-line="473">    // subtype polymorphism.
</span><span class="athl-line" data-athl-line="474">    // The override keyword is optional but makes sure you are actually
</span><span class="athl-line" data-athl-line="475">    // overriding the method in a base class.
</span><span class="athl-line" data-athl-line="476">    void <span style="color: #50fa7b;">print</span>() const <span style="color: #ff79c6;">override</span>;
</span><span class="athl-line" data-athl-line="477">
</span><span class="athl-line" data-athl-line="478"><span style="color: #ff79c6;">private</span>:
</span><span class="athl-line" data-athl-line="479">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">owner</span>;
</span><span class="athl-line" data-athl-line="480">};
</span><span class="athl-line" data-athl-line="481">
</span><span class="athl-line" data-athl-line="482">// Meanwhile, in the corresponding .cpp file:
</span><span class="athl-line" data-athl-line="483">
</span><span class="athl-line" data-athl-line="484">void <span style="color: #a4ffff;">OwnedDog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">setOwner</span>(const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">dogsOwner</span></span>)
</span><span class="athl-line" data-athl-line="485">{
</span><span class="athl-line" data-athl-line="486">    <span style="color: #ffb86c;">owner</span> = <span style="color: #ffb86c;">dogsOwner</span>;
</span><span class="athl-line" data-athl-line="487">}
</span><span class="athl-line" data-athl-line="488">
</span><span class="athl-line" data-athl-line="489">void <span style="color: #a4ffff;">OwnedDog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">print</span>() const
</span><span class="athl-line" data-athl-line="490">{
</span><span class="athl-line" data-athl-line="491">    <span style="color: #a4ffff;">Dog</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">print</span>(); // Call the print function in the base Dog class
</span><span class="athl-line" data-athl-line="492">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Dog is owned by &quot; &lt;&lt; <span style="color: #ffb86c;">owner</span> &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="493">    // Prints &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;
</span><span class="athl-line" data-athl-line="494">    //        &quot;Dog is owned by &lt;owner&gt;&quot;
</span><span class="athl-line" data-athl-line="495">}
</span><span class="athl-line" data-athl-line="496">
</span><span class="athl-line" data-athl-line="497">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="498">// Initialization and Operator Overloading
</span><span class="athl-line" data-athl-line="499">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="500">
</span><span class="athl-line" data-athl-line="501">// In C++ you can overload the behavior of operators such as +, -, *, /, etc.
</span><span class="athl-line" data-athl-line="502">// This is done by defining a function which is called
</span><span class="athl-line" data-athl-line="503">// whenever the operator is used.
</span><span class="athl-line" data-athl-line="504">
</span><span class="athl-line" data-athl-line="505">#include &lt;iostream&gt;
</span><span class="athl-line" data-athl-line="506"><span style="color: #ff79c6;">using</span> <span style="color: #ff79c6;">namespace</span> <span style="color: #ffb86c;">std</span>;
</span><span class="athl-line" data-athl-line="507">
</span><span class="athl-line" data-athl-line="508"><span style="color: #ff79c6;">class</span> Point {
</span><span class="athl-line" data-athl-line="509"><span style="color: #ff79c6;">public</span>:
</span><span class="athl-line" data-athl-line="510">    // Member variables can be given default values in this manner.
</span><span class="athl-line" data-athl-line="511">    double <span style="color: #ffb86c;">x</span> = 0;
</span><span class="athl-line" data-athl-line="512">    double <span style="color: #ffb86c;">y</span> = 0;
</span><span class="athl-line" data-athl-line="513">
</span><span class="athl-line" data-athl-line="514">    // Define a default constructor which does nothing
</span><span class="athl-line" data-athl-line="515">    // but initialize the Point to the default value (0, 0)
</span><span class="athl-line" data-athl-line="516">    <span style="color: #ffb86c;">Point</span>() { };
</span><span class="athl-line" data-athl-line="517">
</span><span class="athl-line" data-athl-line="518">    // The following syntax is known as an initialization list
</span><span class="athl-line" data-athl-line="519">    // and is the proper way to initialize class member values
</span><span class="athl-line" data-athl-line="520">    <span style="color: #ffb86c;">Point</span> (double <span style="color: #ffb86c;">a</span>, double <span style="color: #ffb86c;">b</span>) :
</span><span class="athl-line" data-athl-line="521">        <span style="color: #8be9fd;">x</span>(<span style="color: #ffb86c;">a</span>),
</span><span class="athl-line" data-athl-line="522">        <span style="color: #8be9fd;">y</span>(<span style="color: #ffb86c;">b</span>)
</span><span class="athl-line" data-athl-line="523">    { /* Do nothing except initialize the values */ }
</span><span class="athl-line" data-athl-line="524">
</span><span class="athl-line" data-athl-line="525">    // Overload the + operator.
</span><span class="athl-line" data-athl-line="526">    Point <span style="color: #50fa7b;"><span style="color: #50fa7b;">operator</span>+</span>(const Point<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">rhs</span></span>) const;
</span><span class="athl-line" data-athl-line="527">
</span><span class="athl-line" data-athl-line="528">    // Overload the += operator
</span><span class="athl-line" data-athl-line="529">    Point&amp; <span style="color: #50fa7b;"><span style="color: #50fa7b;">operator</span>+=</span>(const Point<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">rhs</span></span>);
</span><span class="athl-line" data-athl-line="530">
</span><span class="athl-line" data-athl-line="531">    // It would also make sense to add the - and -= operators,
</span><span class="athl-line" data-athl-line="532">    // but we will skip those for brevity.
</span><span class="athl-line" data-athl-line="533">};
</span><span class="athl-line" data-athl-line="534">
</span><span class="athl-line" data-athl-line="535">Point <span style="color: #a4ffff;">Point</span><span style="color: #f8f8f2;">::</span><span style="color: #50fa7b;"><span style="color: #50fa7b;">operator</span>+</span>(const Point<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">rhs</span></span>) const
</span><span class="athl-line" data-athl-line="536">{
</span><span class="athl-line" data-athl-line="537">    // Create a new point that is the sum of this one and rhs.
</span><span class="athl-line" data-athl-line="538">    return <span style="color: #8be9fd;">Point</span>(<span style="color: #ffb86c;">x</span> + <span style="color: #ffb86c;">rhs</span>.<span style="color: #50fa7b;">x</span>, <span style="color: #ffb86c;">y</span> + <span style="color: #ffb86c;">rhs</span>.<span style="color: #50fa7b;">y</span>);
</span><span class="athl-line" data-athl-line="539">}
</span><span class="athl-line" data-athl-line="540">
</span><span class="athl-line" data-athl-line="541">// It&#39;s good practice to return a reference to the leftmost variable of
</span><span class="athl-line" data-athl-line="542">// an assignment. `(a += b) == c` will work this way.
</span><span class="athl-line" data-athl-line="543">Point&amp; <span style="color: #a4ffff;">Point</span><span style="color: #f8f8f2;">::</span><span style="color: #50fa7b;"><span style="color: #50fa7b;">operator</span>+=</span>(const Point<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">rhs</span></span>)
</span><span class="athl-line" data-athl-line="544">{
</span><span class="athl-line" data-athl-line="545">    <span style="color: #ffb86c;">x</span> += <span style="color: #ffb86c;">rhs</span>.<span style="color: #50fa7b;">x</span>;
</span><span class="athl-line" data-athl-line="546">    <span style="color: #ffb86c;">y</span> += <span style="color: #ffb86c;">rhs</span>.<span style="color: #50fa7b;">y</span>;
</span><span class="athl-line" data-athl-line="547">
</span><span class="athl-line" data-athl-line="548">    // `this` is a pointer to the object, on which a method is called.
</span><span class="athl-line" data-athl-line="549">    return *<span style="color: #bd93f9;">this</span>;
</span><span class="athl-line" data-athl-line="550">}
</span><span class="athl-line" data-athl-line="551">
</span><span class="athl-line" data-athl-line="552">int <span style="color: #ffb86c;">main</span> () {
</span><span class="athl-line" data-athl-line="553">    Point <span style="color: #ffb86c;">up</span> (0,1);
</span><span class="athl-line" data-athl-line="554">    Point <span style="color: #ffb86c;">right</span> (1,0);
</span><span class="athl-line" data-athl-line="555">    // This calls the Point + operator
</span><span class="athl-line" data-athl-line="556">    // Point up calls the + (function) with right as its parameter
</span><span class="athl-line" data-athl-line="557">    Point <span style="color: #ffb86c;">result</span> = <span style="color: #ffb86c;">up</span> + <span style="color: #ffb86c;">right</span>;
</span><span class="athl-line" data-athl-line="558">    // Prints &quot;Result is upright (1,1)&quot;
</span><span class="athl-line" data-athl-line="559">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Result is upright (&quot; &lt;&lt; <span style="color: #ffb86c;">result</span>.<span style="color: #50fa7b;">x</span> &lt;&lt; &#39;,&#39; &lt;&lt; <span style="color: #ffb86c;">result</span>.<span style="color: #50fa7b;">y</span> &lt;&lt; &quot;)\n&quot;;
</span><span class="athl-line" data-athl-line="560">    return 0;
</span><span class="athl-line" data-athl-line="561">}
</span><span class="athl-line" data-athl-line="562">
</span><span class="athl-line" data-athl-line="563">/////////////////////
</span><span class="athl-line" data-athl-line="564">// Templates
</span><span class="athl-line" data-athl-line="565">/////////////////////
</span><span class="athl-line" data-athl-line="566">
</span><span class="athl-line" data-athl-line="567">// Templates in C++ are mostly used for generic programming, though they are
</span><span class="athl-line" data-athl-line="568">// much more powerful than generic constructs in other languages. They also
</span><span class="athl-line" data-athl-line="569">// support explicit and partial specialization and functional-style type
</span><span class="athl-line" data-athl-line="570">// classes; in fact, they are a Turing-complete functional language embedded
</span><span class="athl-line" data-athl-line="571">// in C++!
</span><span class="athl-line" data-athl-line="572">
</span><span class="athl-line" data-athl-line="573">// We start with the kind of generic programming you might be familiar with. To
</span><span class="athl-line" data-athl-line="574">// define a class or function that takes a type parameter:
</span><span class="athl-line" data-athl-line="575"><span style="color: #ff79c6;">template</span><span style="color: #f8f8f2;">&lt;</span><span style="color: #ff79c6;">class</span> T<span style="color: #f8f8f2;">&gt;</span>
</span><span class="athl-line" data-athl-line="576"><span style="color: #ff79c6;">class</span> Box {
</span><span class="athl-line" data-athl-line="577"><span style="color: #ff79c6;">public</span>:
</span><span class="athl-line" data-athl-line="578">    // In this class, T can be used as any other type.
</span><span class="athl-line" data-athl-line="579">    void <span style="color: #50fa7b;">insert</span>(const T&amp;) { ... }
</span><span class="athl-line" data-athl-line="580">};
</span><span class="athl-line" data-athl-line="581">
</span><span class="athl-line" data-athl-line="582">// During compilation, the compiler actually generates copies of each template
</span><span class="athl-line" data-athl-line="583">// with parameters substituted, so the full definition of the class must be
</span><span class="athl-line" data-athl-line="584">// present at each invocation. This is why you will see template classes defined
</span><span class="athl-line" data-athl-line="585">// entirely in header files.
</span><span class="athl-line" data-athl-line="586">
</span><span class="athl-line" data-athl-line="587">// To instantiate a template class on the stack:
</span><span class="athl-line" data-athl-line="588">Box<span style="color: #f8f8f2;">&lt;</span>int<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">intBox</span>;
</span><span class="athl-line" data-athl-line="589">
</span><span class="athl-line" data-athl-line="590">// and you can use it as you would expect:
</span><span class="athl-line" data-athl-line="591"><span style="color: #ffb86c;">intBox</span>.<span style="color: #8be9fd;">insert</span>(123);
</span><span class="athl-line" data-athl-line="592">
</span><span class="athl-line" data-athl-line="593">// You can, of course, nest templates:
</span><span class="athl-line" data-athl-line="594">Box<span style="color: #f8f8f2;">&lt;</span>Box<span style="color: #f8f8f2;">&lt;</span>int<span style="color: #f8f8f2;">&gt;</span> <span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">boxOfBox</span>;
</span><span class="athl-line" data-athl-line="595"><span style="color: #ffb86c;">boxOfBox</span>.<span style="color: #8be9fd;">insert</span>(<span style="color: #ffb86c;">intBox</span>);
</span><span class="athl-line" data-athl-line="596">
</span><span class="athl-line" data-athl-line="597">// Until C++11, you had to place a space between the two &#39;&gt;&#39;s, otherwise &#39;&gt;&gt;&#39;
</span><span class="athl-line" data-athl-line="598">// would be parsed as the right shift operator.
</span><span class="athl-line" data-athl-line="599">
</span><span class="athl-line" data-athl-line="600">// You will sometimes see
</span><span class="athl-line" data-athl-line="601">//   template&lt;typename T&gt;
</span><span class="athl-line" data-athl-line="602">// instead. The &#39;class&#39; keyword and &#39;typename&#39; keywords are _mostly_
</span><span class="athl-line" data-athl-line="603">// interchangeable in this case. For the full explanation, see
</span><span class="athl-line" data-athl-line="604">//   https://en.wikipedia.org/wiki/Typename
</span><span class="athl-line" data-athl-line="605">// (yes, that keyword has its own Wikipedia page).
</span><span class="athl-line" data-athl-line="606">
</span><span class="athl-line" data-athl-line="607">// Similarly, a template function:
</span><span class="athl-line" data-athl-line="608"><span style="color: #ff79c6;">template</span><span style="color: #f8f8f2;">&lt;</span><span style="color: #ff79c6;">class</span> T<span style="color: #f8f8f2;">&gt;</span>
</span><span class="athl-line" data-athl-line="609">void <span style="color: #ffb86c;">barkThreeTimes</span>(const T<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">input</span></span>)
</span><span class="athl-line" data-athl-line="610">{
</span><span class="athl-line" data-athl-line="611">    <span style="color: #ffb86c;">input</span>.<span style="color: #8be9fd;">bark</span>();
</span><span class="athl-line" data-athl-line="612">    <span style="color: #ffb86c;">input</span>.<span style="color: #8be9fd;">bark</span>();
</span><span class="athl-line" data-athl-line="613">    <span style="color: #ffb86c;">input</span>.<span style="color: #8be9fd;">bark</span>();
</span><span class="athl-line" data-athl-line="614">}
</span><span class="athl-line" data-athl-line="615">
</span><span class="athl-line" data-athl-line="616">// Notice that nothing is specified about the type parameters here. The compiler
</span><span class="athl-line" data-athl-line="617">// will generate and then type-check every invocation of the template, so the
</span><span class="athl-line" data-athl-line="618">// above function works with any type &#39;T&#39; that has a const &#39;bark&#39; method!
</span><span class="athl-line" data-athl-line="619">
</span><span class="athl-line" data-athl-line="620">Dog <span style="color: #ffb86c;">fluffy</span>;
</span><span class="athl-line" data-athl-line="621"><span style="color: #ffb86c;">fluffy</span>.<span style="color: #8be9fd;">setName</span>(&quot;Fluffy&quot;)
</span><span class="athl-line" data-athl-line="622"><span style="color: #8be9fd;">barkThreeTimes</span>(<span style="color: #ffb86c;">fluffy</span>); // Prints &quot;Fluffy barks&quot; three times.
</span><span class="athl-line" data-athl-line="623">
</span><span class="athl-line" data-athl-line="624">// Template parameters don&#39;t have to be classes:
</span><span class="athl-line" data-athl-line="625"><span style="color: #ff79c6;">template</span><span style="color: #f8f8f2;">&lt;</span>int <span style="color: #ffb86c;">Y</span><span style="color: #f8f8f2;">&gt;</span>
</span><span class="athl-line" data-athl-line="626">void <span style="color: #ffb86c;">printMessage</span>() {
</span><span class="athl-line" data-athl-line="627">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Learn C++ in &quot; &lt;&lt; <span style="color: #ffb86c;">Y</span> &lt;&lt; &quot; minutes!\n&quot;;
</span><span class="athl-line" data-athl-line="628">}
</span><span class="athl-line" data-athl-line="629">
</span><span class="athl-line" data-athl-line="630">// And you can explicitly specialize templates for more efficient code. Of
</span><span class="athl-line" data-athl-line="631">// course, most real-world uses of specialization are not as trivial as this.
</span><span class="athl-line" data-athl-line="632">// Note that you still need to declare the function (or class) as a template
</span><span class="athl-line" data-athl-line="633">// even if you explicitly specified all parameters.
</span><span class="athl-line" data-athl-line="634"><span style="color: #ff79c6;">template</span><span style="color: #f8f8f2;">&lt;</span><span style="color: #f8f8f2;">&gt;</span>
</span><span class="athl-line" data-athl-line="635">void <span style="color: #50fa7b;">printMessage</span><span style="color: #f8f8f2;">&lt;</span>10<span style="color: #f8f8f2;">&gt;</span>() {
</span><span class="athl-line" data-athl-line="636">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Learn C++ faster in only 10 minutes!\n&quot;;
</span><span class="athl-line" data-athl-line="637">}
</span><span class="athl-line" data-athl-line="638">
</span><span class="athl-line" data-athl-line="639"><span style="color: #50fa7b;">printMessage</span><span style="color: #f8f8f2;">&lt;</span>20<span style="color: #f8f8f2;">&gt;</span>();  // Prints &quot;Learn C++ in 20 minutes!&quot;
</span><span class="athl-line" data-athl-line="640"><span style="color: #50fa7b;">printMessage</span><span style="color: #f8f8f2;">&lt;</span>10<span style="color: #f8f8f2;">&gt;</span>();  // Prints &quot;Learn C++ faster in only 10 minutes!&quot;
</span><span class="athl-line" data-athl-line="641">
</span><span class="athl-line" data-athl-line="642">
</span><span class="athl-line" data-athl-line="643">/////////////////////
</span><span class="athl-line" data-athl-line="644">// Exception Handling
</span><span class="athl-line" data-athl-line="645">/////////////////////
</span><span class="athl-line" data-athl-line="646">
</span><span class="athl-line" data-athl-line="647">// The standard library provides a few exception types
</span><span class="athl-line" data-athl-line="648">// (see https://en.cppreference.com/w/cpp/error/exception)
</span><span class="athl-line" data-athl-line="649">// but any type can be thrown as an exception
</span><span class="athl-line" data-athl-line="650">#include &lt;exception&gt;
</span><span class="athl-line" data-athl-line="651">#include &lt;stdexcept&gt;
</span><span class="athl-line" data-athl-line="652">
</span><span class="athl-line" data-athl-line="653">// All exceptions thrown inside the _try_ block can be caught by subsequent
</span><span class="athl-line" data-athl-line="654">// _catch_ handlers.
</span><span class="athl-line" data-athl-line="655"><span style="color: #bd93f9;">try</span> {
</span><span class="athl-line" data-athl-line="656">    // Do not allocate exceptions on the heap using _new_.
</span><span class="athl-line" data-athl-line="657">    <span style="color: #bd93f9;">throw</span> <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">runtime_error</span>(&quot;A problem occurred&quot;);
</span><span class="athl-line" data-athl-line="658">}
</span><span class="athl-line" data-athl-line="659">
</span><span class="athl-line" data-athl-line="660">// Catch exceptions by const reference if they are objects
</span><span class="athl-line" data-athl-line="661"><span style="color: #bd93f9;">catch</span> (const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>exception<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">ex</span></span>)
</span><span class="athl-line" data-athl-line="662">{
</span><span class="athl-line" data-athl-line="663">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">ex</span>.<span style="color: #8be9fd;">what</span>();
</span><span class="athl-line" data-athl-line="664">}
</span><span class="athl-line" data-athl-line="665">
</span><span class="athl-line" data-athl-line="666">// Catches any exception not caught by previous _catch_ blocks
</span><span class="athl-line" data-athl-line="667"><span style="color: #bd93f9;">catch</span> (...)
</span><span class="athl-line" data-athl-line="668">{
</span><span class="athl-line" data-athl-line="669">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; &quot;Unknown exception caught&quot;;
</span><span class="athl-line" data-athl-line="670">    <span style="color: #bd93f9;">throw</span>; // Re-throws the exception
</span><span class="athl-line" data-athl-line="671">}
</span><span class="athl-line" data-athl-line="672">
</span><span class="athl-line" data-athl-line="673">///////
</span><span class="athl-line" data-athl-line="674">// RAII
</span><span class="athl-line" data-athl-line="675">///////
</span><span class="athl-line" data-athl-line="676">
</span><span class="athl-line" data-athl-line="677">// RAII stands for &quot;Resource Acquisition Is Initialization&quot;.
</span><span class="athl-line" data-athl-line="678">// It is often considered the most powerful paradigm in C++
</span><span class="athl-line" data-athl-line="679">// and is the simple concept that a constructor for an object
</span><span class="athl-line" data-athl-line="680">// acquires that object&#39;s resources and the destructor releases them.
</span><span class="athl-line" data-athl-line="681">
</span><span class="athl-line" data-athl-line="682">// To understand how this is useful,
</span><span class="athl-line" data-athl-line="683">// consider a function that uses a C file handle:
</span><span class="athl-line" data-athl-line="684">void <span style="color: #ffb86c;">doSomethingWithAFile</span>(const char* <span style="color: #ffb86c;">filename</span>)
</span><span class="athl-line" data-athl-line="685">{
</span><span class="athl-line" data-athl-line="686">    // To begin with, assume nothing can fail.
</span><span class="athl-line" data-athl-line="687">
</span><span class="athl-line" data-athl-line="688">    FILE* <span style="color: #ffb86c;">fh</span> = <span style="color: #8be9fd;">fopen</span>(<span style="color: #ffb86c;">filename</span>, &quot;r&quot;); // Open the file in read mode.
</span><span class="athl-line" data-athl-line="689">    if (<span style="color: #ffb86c;">fh</span> == NULL) {
</span><span class="athl-line" data-athl-line="690">        // Handle possible error
</span><span class="athl-line" data-athl-line="691">    }
</span><span class="athl-line" data-athl-line="692">
</span><span class="athl-line" data-athl-line="693">    <span style="color: #8be9fd;">doSomethingWithTheFile</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="694">    <span style="color: #8be9fd;">doSomethingElseWithIt</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="695">
</span><span class="athl-line" data-athl-line="696">    <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Close the file handle.
</span><span class="athl-line" data-athl-line="697">}
</span><span class="athl-line" data-athl-line="698">
</span><span class="athl-line" data-athl-line="699">// Unfortunately, things are quickly complicated by error handling.
</span><span class="athl-line" data-athl-line="700">// Suppose fopen can fail, and that doSomethingWithTheFile and
</span><span class="athl-line" data-athl-line="701">// doSomethingElseWithIt return error codes if they fail.
</span><span class="athl-line" data-athl-line="702">//  (Exceptions are the preferred way of handling failure,
</span><span class="athl-line" data-athl-line="703">//   but some programmers, especially those with a C background,
</span><span class="athl-line" data-athl-line="704">//   disagree on the utility of exceptions).
</span><span class="athl-line" data-athl-line="705">// We now have to check each call for failure and close the file handle
</span><span class="athl-line" data-athl-line="706">// if a problem occurred.
</span><span class="athl-line" data-athl-line="707">bool <span style="color: #ffb86c;">doSomethingWithAFile</span>(const char* <span style="color: #ffb86c;">filename</span>)
</span><span class="athl-line" data-athl-line="708">{
</span><span class="athl-line" data-athl-line="709">    FILE* <span style="color: #ffb86c;">fh</span> = <span style="color: #8be9fd;">fopen</span>(<span style="color: #ffb86c;">filename</span>, &quot;r&quot;); // Open the file in read mode
</span><span class="athl-line" data-athl-line="710">    if (<span style="color: #ffb86c;">fh</span> == <span style="color: #bd93f9;">nullptr</span>) // The returned pointer is null on failure.
</span><span class="athl-line" data-athl-line="711">        return <span style="color: #bd93f9;">false</span>; // Report that failure to the caller.
</span><span class="athl-line" data-athl-line="712">
</span><span class="athl-line" data-athl-line="713">    // Assume each function returns false if it failed
</span><span class="athl-line" data-athl-line="714">    if (!<span style="color: #8be9fd;">doSomethingWithTheFile</span>(<span style="color: #ffb86c;">fh</span>)) {
</span><span class="athl-line" data-athl-line="715">        <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Close the file handle so it doesn&#39;t leak.
</span><span class="athl-line" data-athl-line="716">        return <span style="color: #bd93f9;">false</span>; // Propagate the error.
</span><span class="athl-line" data-athl-line="717">    }
</span><span class="athl-line" data-athl-line="718">    if (!<span style="color: #8be9fd;">doSomethingElseWithIt</span>(<span style="color: #ffb86c;">fh</span>)) {
</span><span class="athl-line" data-athl-line="719">        <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Close the file handle so it doesn&#39;t leak.
</span><span class="athl-line" data-athl-line="720">        return <span style="color: #bd93f9;">false</span>; // Propagate the error.
</span><span class="athl-line" data-athl-line="721">    }
</span><span class="athl-line" data-athl-line="722">
</span><span class="athl-line" data-athl-line="723">    <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Close the file handle so it doesn&#39;t leak.
</span><span class="athl-line" data-athl-line="724">    return <span style="color: #bd93f9;">true</span>; // Indicate success
</span><span class="athl-line" data-athl-line="725">}
</span><span class="athl-line" data-athl-line="726">
</span><span class="athl-line" data-athl-line="727">// C programmers often clean this up a little bit using goto:
</span><span class="athl-line" data-athl-line="728">bool <span style="color: #ffb86c;">doSomethingWithAFile</span>(const char* <span style="color: #ffb86c;">filename</span>)
</span><span class="athl-line" data-athl-line="729">{
</span><span class="athl-line" data-athl-line="730">    FILE* <span style="color: #ffb86c;">fh</span> = <span style="color: #8be9fd;">fopen</span>(<span style="color: #ffb86c;">filename</span>, &quot;r&quot;);
</span><span class="athl-line" data-athl-line="731">    if (<span style="color: #ffb86c;">fh</span> == <span style="color: #bd93f9;">nullptr</span>)
</span><span class="athl-line" data-athl-line="732">        return <span style="color: #bd93f9;">false</span>;
</span><span class="athl-line" data-athl-line="733">
</span><span class="athl-line" data-athl-line="734">    if (!<span style="color: #8be9fd;">doSomethingWithTheFile</span>(<span style="color: #ffb86c;">fh</span>))
</span><span class="athl-line" data-athl-line="735">        goto failure;
</span><span class="athl-line" data-athl-line="736">
</span><span class="athl-line" data-athl-line="737">    if (!<span style="color: #8be9fd;">doSomethingElseWithIt</span>(<span style="color: #ffb86c;">fh</span>))
</span><span class="athl-line" data-athl-line="738">        goto failure;
</span><span class="athl-line" data-athl-line="739">
</span><span class="athl-line" data-athl-line="740">    <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Close the file
</span><span class="athl-line" data-athl-line="741">    return <span style="color: #bd93f9;">true</span>; // Indicate success
</span><span class="athl-line" data-athl-line="742">
</span><span class="athl-line" data-athl-line="743">failure:
</span><span class="athl-line" data-athl-line="744">    <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="745">    return <span style="color: #bd93f9;">false</span>; // Propagate the error
</span><span class="athl-line" data-athl-line="746">}
</span><span class="athl-line" data-athl-line="747">
</span><span class="athl-line" data-athl-line="748">// If the functions indicate errors using exceptions,
</span><span class="athl-line" data-athl-line="749">// things are a little cleaner, but still sub-optimal.
</span><span class="athl-line" data-athl-line="750">void <span style="color: #ffb86c;">doSomethingWithAFile</span>(const char* <span style="color: #ffb86c;">filename</span>)
</span><span class="athl-line" data-athl-line="751">{
</span><span class="athl-line" data-athl-line="752">    FILE* <span style="color: #ffb86c;">fh</span> = <span style="color: #8be9fd;">fopen</span>(<span style="color: #ffb86c;">filename</span>, &quot;r&quot;); // Open the file in shared_ptrread mode
</span><span class="athl-line" data-athl-line="753">    if (<span style="color: #ffb86c;">fh</span> == <span style="color: #bd93f9;">nullptr</span>)
</span><span class="athl-line" data-athl-line="754">        <span style="color: #bd93f9;">throw</span> <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">runtime_error</span>(&quot;Could not open the file.&quot;);
</span><span class="athl-line" data-athl-line="755">
</span><span class="athl-line" data-athl-line="756">    <span style="color: #bd93f9;">try</span> {
</span><span class="athl-line" data-athl-line="757">        <span style="color: #8be9fd;">doSomethingWithTheFile</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="758">        <span style="color: #8be9fd;">doSomethingElseWithIt</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="759">    }
</span><span class="athl-line" data-athl-line="760">    <span style="color: #bd93f9;">catch</span> (...) {
</span><span class="athl-line" data-athl-line="761">        <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Be sure to close the file if an error occurs.
</span><span class="athl-line" data-athl-line="762">        <span style="color: #bd93f9;">throw</span>; // Then re-throw the exception.
</span><span class="athl-line" data-athl-line="763">    }
</span><span class="athl-line" data-athl-line="764">
</span><span class="athl-line" data-athl-line="765">    <span style="color: #8be9fd;">fclose</span>(<span style="color: #ffb86c;">fh</span>); // Close the file
</span><span class="athl-line" data-athl-line="766">    // Everything succeeded
</span><span class="athl-line" data-athl-line="767">}
</span><span class="athl-line" data-athl-line="768">
</span><span class="athl-line" data-athl-line="769">// Compare this to the use of C++&#39;s file stream class (fstream)
</span><span class="athl-line" data-athl-line="770">// fstream uses its destructor to close the file.
</span><span class="athl-line" data-athl-line="771">// Recall from above that destructors are automatically called
</span><span class="athl-line" data-athl-line="772">// whenever an object falls out of scope.
</span><span class="athl-line" data-athl-line="773">void <span style="color: #ffb86c;">doSomethingWithAFile</span>(const <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">filename</span></span>)
</span><span class="athl-line" data-athl-line="774">{
</span><span class="athl-line" data-athl-line="775">    // ifstream is short for input file stream
</span><span class="athl-line" data-athl-line="776">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>ifstream <span style="color: #ffb86c;">fh</span>(filename); // Open the file
</span><span class="athl-line" data-athl-line="777">
</span><span class="athl-line" data-athl-line="778">    // Do things with the file
</span><span class="athl-line" data-athl-line="779">    <span style="color: #8be9fd;">doSomethingWithTheFile</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="780">    <span style="color: #8be9fd;">doSomethingElseWithIt</span>(<span style="color: #ffb86c;">fh</span>);
</span><span class="athl-line" data-athl-line="781">
</span><span class="athl-line" data-athl-line="782">} // The file is automatically closed here by the destructor
</span><span class="athl-line" data-athl-line="783">
</span><span class="athl-line" data-athl-line="784">// This has _massive_ advantages:
</span><span class="athl-line" data-athl-line="785">// 1. No matter what happens,
</span><span class="athl-line" data-athl-line="786">//    the resource (in this case the file handle) will be cleaned up.
</span><span class="athl-line" data-athl-line="787">//    Once you write the destructor correctly,
</span><span class="athl-line" data-athl-line="788">//    It is _impossible_ to forget to close the handle and leak the resource.
</span><span class="athl-line" data-athl-line="789">// 2. Note that the code is much cleaner.
</span><span class="athl-line" data-athl-line="790">//    The destructor handles closing the file behind the scenes
</span><span class="athl-line" data-athl-line="791">//    without you having to worry about it.
</span><span class="athl-line" data-athl-line="792">// 3. The code is exception safe.
</span><span class="athl-line" data-athl-line="793">//    An exception can be thrown anywhere in the function and cleanup
</span><span class="athl-line" data-athl-line="794">//    will still occur.
</span><span class="athl-line" data-athl-line="795">
</span><span class="athl-line" data-athl-line="796">// All idiomatic C++ code uses RAII extensively for all resources.
</span><span class="athl-line" data-athl-line="797">// Additional examples include
</span><span class="athl-line" data-athl-line="798">// - Memory using unique_ptr and shared_ptr
</span><span class="athl-line" data-athl-line="799">// - Containers - the standard library linked list,
</span><span class="athl-line" data-athl-line="800">//   vector (i.e. self-resizing array), hash maps, and so on
</span><span class="athl-line" data-athl-line="801">//   all automatically destroy their contents when they fall out of scope.
</span><span class="athl-line" data-athl-line="802">// - Mutexes using lock_guard and unique_lock
</span><span class="athl-line" data-athl-line="803">
</span><span class="athl-line" data-athl-line="804">
</span><span class="athl-line" data-athl-line="805">/////////////////////
</span><span class="athl-line" data-athl-line="806">// Smart Pointer
</span><span class="athl-line" data-athl-line="807">/////////////////////
</span><span class="athl-line" data-athl-line="808">
</span><span class="athl-line" data-athl-line="809">// Generally a smart pointer is a class which wraps a &quot;raw pointer&quot; (usage of &quot;new&quot;
</span><span class="athl-line" data-athl-line="810">// respectively malloc/calloc in C). The goal is to be able to
</span><span class="athl-line" data-athl-line="811">// manage the lifetime of the object being pointed to without ever needing to explicitly delete
</span><span class="athl-line" data-athl-line="812">// the object. The term itself simply describes a set of pointers with the
</span><span class="athl-line" data-athl-line="813">// mentioned abstraction.
</span><span class="athl-line" data-athl-line="814">// Smart pointers should be preferred over raw pointers, to prevent
</span><span class="athl-line" data-athl-line="815">// risky memory leaks, which happen if you forget to delete an object.
</span><span class="athl-line" data-athl-line="816">
</span><span class="athl-line" data-athl-line="817">// Usage of a raw pointer:
</span><span class="athl-line" data-athl-line="818">Dog* <span style="color: #ffb86c;">ptr</span> = <span style="color: #ff79c6;">new</span> Dog();
</span><span class="athl-line" data-athl-line="819"><span style="color: #ffb86c;">ptr</span>-&gt;<span style="color: #8be9fd;">bark</span>();
</span><span class="athl-line" data-athl-line="820"><span style="color: #ff79c6;">delete</span> <span style="color: #ffb86c;">ptr</span>;
</span><span class="athl-line" data-athl-line="821">
</span><span class="athl-line" data-athl-line="822">// By using a smart pointer, you don&#39;t have to worry about the deletion
</span><span class="athl-line" data-athl-line="823">// of the object anymore.
</span><span class="athl-line" data-athl-line="824">// A smart pointer describes a policy, to count the references to the
</span><span class="athl-line" data-athl-line="825">// pointer. The object gets destroyed when the last
</span><span class="athl-line" data-athl-line="826">// reference to the object gets destroyed.
</span><span class="athl-line" data-athl-line="827">
</span><span class="athl-line" data-athl-line="828">// Usage of &quot;std::shared_ptr&quot;:
</span><span class="athl-line" data-athl-line="829">void <span style="color: #ffb86c;">foo</span>()
</span><span class="athl-line" data-athl-line="830">{
</span><span class="athl-line" data-athl-line="831">    // It&#39;s no longer necessary to delete the Dog.
</span><span class="athl-line" data-athl-line="832">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>shared_ptr<span style="color: #f8f8f2;">&lt;</span>Dog<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">doggo</span>(<span style="color: #ff79c6;">new</span> Dog());
</span><span class="athl-line" data-athl-line="833">    <span style="color: #ffb86c;">doggo</span>-&gt;<span style="color: #8be9fd;">bark</span>();
</span><span class="athl-line" data-athl-line="834">}
</span><span class="athl-line" data-athl-line="835">
</span><span class="athl-line" data-athl-line="836">// Beware of possible circular references!!!
</span><span class="athl-line" data-athl-line="837">// There will be always a reference, so it will be never destroyed!
</span><span class="athl-line" data-athl-line="838"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>shared_ptr<span style="color: #f8f8f2;">&lt;</span>Dog<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">doggo_one</span>(<span style="color: #ff79c6;">new</span> Dog());
</span><span class="athl-line" data-athl-line="839"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>shared_ptr<span style="color: #f8f8f2;">&lt;</span>Dog<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">doggo_two</span>(<span style="color: #ff79c6;">new</span> Dog());
</span><span class="athl-line" data-athl-line="840"><span style="color: #ffb86c;">doggo_one</span> = <span style="color: #ffb86c;">doggo_two</span>; // p1 references p2
</span><span class="athl-line" data-athl-line="841"><span style="color: #ffb86c;">doggo_two</span> = <span style="color: #ffb86c;">doggo_one</span>; // p2 references p1
</span><span class="athl-line" data-athl-line="842">
</span><span class="athl-line" data-athl-line="843">// There are several kinds of smart pointers.
</span><span class="athl-line" data-athl-line="844">// The way you have to use them is always the same.
</span><span class="athl-line" data-athl-line="845">// This leads us to the question: when should we use each kind of smart pointer?
</span><span class="athl-line" data-athl-line="846">// std::unique_ptr - use it when you just want to hold one reference to
</span><span class="athl-line" data-athl-line="847">// the object.
</span><span class="athl-line" data-athl-line="848">// std::shared_ptr - use it when you want to hold multiple references to the
</span><span class="athl-line" data-athl-line="849">// same object and want to make sure that it&#39;s deallocated
</span><span class="athl-line" data-athl-line="850">// when all references are gone.
</span><span class="athl-line" data-athl-line="851">// std::weak_ptr - use it when you want to access
</span><span class="athl-line" data-athl-line="852">// the underlying object of a std::shared_ptr without causing that object to stay allocated.
</span><span class="athl-line" data-athl-line="853">// Weak pointers are used to prevent circular referencing.
</span><span class="athl-line" data-athl-line="854">
</span><span class="athl-line" data-athl-line="855">
</span><span class="athl-line" data-athl-line="856">/////////////////////
</span><span class="athl-line" data-athl-line="857">// Containers
</span><span class="athl-line" data-athl-line="858">/////////////////////
</span><span class="athl-line" data-athl-line="859">
</span><span class="athl-line" data-athl-line="860">// Containers or the Standard Template Library are some predefined templates.
</span><span class="athl-line" data-athl-line="861">// They manage the storage space for its elements and provide
</span><span class="athl-line" data-athl-line="862">// member functions to access and manipulate them.
</span><span class="athl-line" data-athl-line="863">
</span><span class="athl-line" data-athl-line="864">// Few containers are as follows:
</span><span class="athl-line" data-athl-line="865">
</span><span class="athl-line" data-athl-line="866">// Vector (Dynamic array)
</span><span class="athl-line" data-athl-line="867">// Allow us to Define the Array or list of objects at run time
</span><span class="athl-line" data-athl-line="868">#include &lt;vector&gt;
</span><span class="athl-line" data-athl-line="869"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>string <span style="color: #ffb86c;">val</span>;
</span><span class="athl-line" data-athl-line="870"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>vector<span style="color: #f8f8f2;">&lt;</span>string<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">my_vector</span>; // initialize the vector
</span><span class="athl-line" data-athl-line="871"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cin</span> &gt;&gt; <span style="color: #ffb86c;">val</span>;
</span><span class="athl-line" data-athl-line="872">
</span><span class="athl-line" data-athl-line="873"><span style="color: #ffb86c;">my_vector</span>.<span style="color: #8be9fd;">push_back</span>(<span style="color: #ffb86c;">val</span>); // will push the value of &#39;val&#39; into vector (&quot;array&quot;) my_vector
</span><span class="athl-line" data-athl-line="874"><span style="color: #ffb86c;">my_vector</span>.<span style="color: #8be9fd;">push_back</span>(<span style="color: #ffb86c;">val</span>); // will push the value into the vector again (now having two elements)
</span><span class="athl-line" data-athl-line="875">
</span><span class="athl-line" data-athl-line="876">// To iterate through a vector we have 2 choices:
</span><span class="athl-line" data-athl-line="877">// Either classic looping (iterating through the vector from index 0 to its last index):
</span><span class="athl-line" data-athl-line="878">for (int <span style="color: #ffb86c;">i</span> = 0; <span style="color: #ffb86c;">i</span> &lt; <span style="color: #ffb86c;">my_vector</span>.<span style="color: #8be9fd;">size</span>(); <span style="color: #ffb86c;">i</span>++) {
</span><span class="athl-line" data-athl-line="879">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">my_vector</span>[<span style="color: #ffb86c;">i</span>] &lt;&lt; &#39;\n&#39;; // for accessing a vector&#39;s element we can use the operator []
</span><span class="athl-line" data-athl-line="880">}
</span><span class="athl-line" data-athl-line="881">
</span><span class="athl-line" data-athl-line="882">// or using an iterator:
</span><span class="athl-line" data-athl-line="883">vector<span style="color: #f8f8f2;">&lt;</span>string<span style="color: #f8f8f2;">&gt;</span><span style="color: #f8f8f2;">::</span>iterator <span style="color: #ffb86c;">it</span>; // initialize the iterator for vector
</span><span class="athl-line" data-athl-line="884">for (<span style="color: #ffb86c;">it</span> = <span style="color: #ffb86c;">my_vector</span>.<span style="color: #8be9fd;">begin</span>(); <span style="color: #ffb86c;">it</span> != <span style="color: #ffb86c;">my_vector</span>.<span style="color: #8be9fd;">end</span>(); ++<span style="color: #ffb86c;">it</span>) {
</span><span class="athl-line" data-athl-line="885">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; *<span style="color: #ffb86c;">it</span>  &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="886">}
</span><span class="athl-line" data-athl-line="887">
</span><span class="athl-line" data-athl-line="888">// Set
</span><span class="athl-line" data-athl-line="889">// Sets are containers that store unique elements following a specific order.
</span><span class="athl-line" data-athl-line="890">// Set is a very useful container to store unique values in sorted order
</span><span class="athl-line" data-athl-line="891">// without any other functions or code.
</span><span class="athl-line" data-athl-line="892">
</span><span class="athl-line" data-athl-line="893">#include&lt;set&gt;
</span><span class="athl-line" data-athl-line="894"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>set<span style="color: #f8f8f2;">&lt;</span>int<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">ST</span>;    // Will initialize the set of int data type
</span><span class="athl-line" data-athl-line="895"><span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">insert</span>(30);  // Will insert the value 30 in set ST
</span><span class="athl-line" data-athl-line="896"><span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">insert</span>(10);  // Will insert the value 10 in set ST
</span><span class="athl-line" data-athl-line="897"><span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">insert</span>(20);  // Will insert the value 20 in set ST
</span><span class="athl-line" data-athl-line="898"><span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">insert</span>(30);  // Will insert the value 30 in set ST
</span><span class="athl-line" data-athl-line="899">// Now elements of sets are as follows
</span><span class="athl-line" data-athl-line="900">//  10 20 30
</span><span class="athl-line" data-athl-line="901">
</span><span class="athl-line" data-athl-line="902">// To erase an element
</span><span class="athl-line" data-athl-line="903"><span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">erase</span>(20);  // Will erase element with value 20
</span><span class="athl-line" data-athl-line="904">// Set ST: 10 30
</span><span class="athl-line" data-athl-line="905">// To iterate through Set we use iterators
</span><span class="athl-line" data-athl-line="906"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>set<span style="color: #f8f8f2;">&lt;</span>int<span style="color: #f8f8f2;">&gt;</span><span style="color: #f8f8f2;">::</span>iterator <span style="color: #ffb86c;">it</span>;
</span><span class="athl-line" data-athl-line="907">for (<span style="color: #ffb86c;">it</span> = <span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">begin</span>(); <span style="color: #ffb86c;">it</span> != <span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">end</span>(); <span style="color: #ffb86c;">it</span>++) {
</span><span class="athl-line" data-athl-line="908">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; *<span style="color: #ffb86c;">it</span> &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="909">}
</span><span class="athl-line" data-athl-line="910">// Output:
</span><span class="athl-line" data-athl-line="911">// 10
</span><span class="athl-line" data-athl-line="912">// 30
</span><span class="athl-line" data-athl-line="913">
</span><span class="athl-line" data-athl-line="914">// To clear the complete container we use Container_name.clear()
</span><span class="athl-line" data-athl-line="915"><span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">clear</span>();
</span><span class="athl-line" data-athl-line="916"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">ST</span>.<span style="color: #8be9fd;">size</span>();  // will print the size of set ST
</span><span class="athl-line" data-athl-line="917">// Output: 0
</span><span class="athl-line" data-athl-line="918">
</span><span class="athl-line" data-athl-line="919">// NOTE: for duplicate elements we can use multiset
</span><span class="athl-line" data-athl-line="920">// NOTE: For hash sets, use unordered_set. They are more efficient but
</span><span class="athl-line" data-athl-line="921">// do not preserve order. unordered_set is available since C++11
</span><span class="athl-line" data-athl-line="922">
</span><span class="athl-line" data-athl-line="923">// Map
</span><span class="athl-line" data-athl-line="924">// Maps store elements formed by a combination of a key value
</span><span class="athl-line" data-athl-line="925">// and a mapped value, following a specific order.
</span><span class="athl-line" data-athl-line="926">
</span><span class="athl-line" data-athl-line="927">#include&lt;map&gt;
</span><span class="athl-line" data-athl-line="928"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>map<span style="color: #f8f8f2;">&lt;</span>char, int<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">mymap</span>;  // Will initialize the map with key as char and value as int
</span><span class="athl-line" data-athl-line="929">
</span><span class="athl-line" data-athl-line="930"><span style="color: #ffb86c;">mymap</span>.<span style="color: #8be9fd;">insert</span>(<span style="color: #50fa7b;">pair</span><span style="color: #f8f8f2;">&lt;</span>char,int<span style="color: #f8f8f2;">&gt;</span>(&#39;A&#39;,1));
</span><span class="athl-line" data-athl-line="931">// Will insert value 1 for key A
</span><span class="athl-line" data-athl-line="932"><span style="color: #ffb86c;">mymap</span>.<span style="color: #8be9fd;">insert</span>(<span style="color: #50fa7b;">pair</span><span style="color: #f8f8f2;">&lt;</span>char,int<span style="color: #f8f8f2;">&gt;</span>(&#39;Z&#39;,26));
</span><span class="athl-line" data-athl-line="933">// Will insert value 26 for key Z
</span><span class="athl-line" data-athl-line="934">
</span><span class="athl-line" data-athl-line="935">// To iterate
</span><span class="athl-line" data-athl-line="936"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>map<span style="color: #f8f8f2;">&lt;</span>char,int<span style="color: #f8f8f2;">&gt;</span><span style="color: #f8f8f2;">::</span>iterator <span style="color: #ffb86c;">it</span>;
</span><span class="athl-line" data-athl-line="937">for (<span style="color: #ffb86c;">it</span> = <span style="color: #ffb86c;">mymap</span>.<span style="color: #8be9fd;">begin</span>(); <span style="color: #ffb86c;">it</span> != <span style="color: #ffb86c;">mymap</span>.<span style="color: #8be9fd;">end</span>(); ++<span style="color: #ffb86c;">it</span>)
</span><span class="athl-line" data-athl-line="938">    <span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">it</span>-&gt;<span style="color: #50fa7b;">first</span> &lt;&lt; &quot;-&gt;&quot; &lt;&lt; <span style="color: #ffb86c;">it</span>-&gt;<span style="color: #50fa7b;">second</span> &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="939">// Output:
</span><span class="athl-line" data-athl-line="940">// A-&gt;1
</span><span class="athl-line" data-athl-line="941">// Z-&gt;26
</span><span class="athl-line" data-athl-line="942">
</span><span class="athl-line" data-athl-line="943">// To find the value corresponding to a key
</span><span class="athl-line" data-athl-line="944"><span style="color: #ffb86c;">it</span> = <span style="color: #ffb86c;">mymap</span>.<span style="color: #8be9fd;">find</span>(&#39;Z&#39;);
</span><span class="athl-line" data-athl-line="945"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">it</span>-&gt;<span style="color: #50fa7b;">second</span>;
</span><span class="athl-line" data-athl-line="946">
</span><span class="athl-line" data-athl-line="947">// Output: 26
</span><span class="athl-line" data-athl-line="948">
</span><span class="athl-line" data-athl-line="949">// NOTE: For hash maps, use unordered_map. They are more efficient but do
</span><span class="athl-line" data-athl-line="950">// not preserve order. unordered_map is available since C++11.
</span><span class="athl-line" data-athl-line="951">
</span><span class="athl-line" data-athl-line="952">// Containers with object keys of non-primitive values (custom classes) require
</span><span class="athl-line" data-athl-line="953">// compare function in the object itself or as a function pointer. Primitives
</span><span class="athl-line" data-athl-line="954">// have default comparators, but you can override it.
</span><span class="athl-line" data-athl-line="955"><span style="color: #ff79c6;">class</span> Foo {
</span><span class="athl-line" data-athl-line="956"><span style="color: #ff79c6;">public</span>:
</span><span class="athl-line" data-athl-line="957">    int <span style="color: #ffb86c;">j</span>;
</span><span class="athl-line" data-athl-line="958">    <span style="color: #ffb86c;">Foo</span>(int <span style="color: #ffb86c;">a</span>) : <span style="color: #8be9fd;">j</span>(<span style="color: #ffb86c;">a</span>) {}
</span><span class="athl-line" data-athl-line="959">};
</span><span class="athl-line" data-athl-line="960">struct compareFunction {
</span><span class="athl-line" data-athl-line="961">    bool <span style="color: #50fa7b;"><span style="color: #50fa7b;">operator</span>()</span>(const Foo<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">a</span></span>, const Foo<span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">b</span></span>) const {
</span><span class="athl-line" data-athl-line="962">        return <span style="color: #ffb86c;">a</span>.<span style="color: #50fa7b;">j</span> &lt; <span style="color: #ffb86c;">b</span>.<span style="color: #50fa7b;">j</span>;
</span><span class="athl-line" data-athl-line="963">    }
</span><span class="athl-line" data-athl-line="964">};
</span><span class="athl-line" data-athl-line="965">// this isn&#39;t allowed (although it can vary depending on compiler)
</span><span class="athl-line" data-athl-line="966">// std::map&lt;Foo, int&gt; fooMap;
</span><span class="athl-line" data-athl-line="967"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>map<span style="color: #f8f8f2;">&lt;</span>Foo, int, compareFunction<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">fooMap</span>;
</span><span class="athl-line" data-athl-line="968"><span style="color: #ffb86c;">fooMap</span>[<span style="color: #8be9fd;">Foo</span>(1)]  = 1;
</span><span class="athl-line" data-athl-line="969"><span style="color: #ffb86c;">fooMap</span>.<span style="color: #8be9fd;">find</span>(<span style="color: #8be9fd;">Foo</span>(1)); //true
</span><span class="athl-line" data-athl-line="970">
</span><span class="athl-line" data-athl-line="971">
</span><span class="athl-line" data-athl-line="972">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="973">// Lambda Expressions (C++11 and above)
</span><span class="athl-line" data-athl-line="974">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="975">
</span><span class="athl-line" data-athl-line="976">// lambdas are a convenient way of defining an anonymous function
</span><span class="athl-line" data-athl-line="977">// object right at the location where it is invoked or passed as
</span><span class="athl-line" data-athl-line="978">// an argument to a function.
</span><span class="athl-line" data-athl-line="979">
</span><span class="athl-line" data-athl-line="980">// For example, consider sorting a vector of pairs using the second
</span><span class="athl-line" data-athl-line="981">// value of the pair
</span><span class="athl-line" data-athl-line="982">
</span><span class="athl-line" data-athl-line="983"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>vector<span style="color: #f8f8f2;">&lt;</span>pair<span style="color: #f8f8f2;">&lt;</span>int, int<span style="color: #f8f8f2;">&gt;</span> <span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">tester</span>;
</span><span class="athl-line" data-athl-line="984"><span style="color: #ffb86c;">tester</span>.<span style="color: #8be9fd;">push_back</span>(<span style="color: #8be9fd;">make_pair</span>(3, 6));
</span><span class="athl-line" data-athl-line="985"><span style="color: #ffb86c;">tester</span>.<span style="color: #8be9fd;">push_back</span>(<span style="color: #8be9fd;">make_pair</span>(1, 9));
</span><span class="athl-line" data-athl-line="986"><span style="color: #ffb86c;">tester</span>.<span style="color: #8be9fd;">push_back</span>(<span style="color: #8be9fd;">make_pair</span>(5, 0));
</span><span class="athl-line" data-athl-line="987">
</span><span class="athl-line" data-athl-line="988">// Pass a lambda expression as third argument to the sort function
</span><span class="athl-line" data-athl-line="989">// sort is from the &lt;algorithm&gt; header
</span><span class="athl-line" data-athl-line="990">
</span><span class="athl-line" data-athl-line="991"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #8be9fd;">sort</span>(<span style="color: #ffb86c;">tester</span>.<span style="color: #8be9fd;">begin</span>(), <span style="color: #ffb86c;">tester</span>.<span style="color: #8be9fd;">end</span>(), [](const pair<span style="color: #f8f8f2;">&lt;</span>int, int<span style="color: #f8f8f2;">&gt;</span><span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">lhs</span></span>, const pair<span style="color: #f8f8f2;">&lt;</span>int, int<span style="color: #f8f8f2;">&gt;</span><span style="color: #ffb86c;">&amp; <span style="color: #ffb86c;">rhs</span></span>) {
</span><span class="athl-line" data-athl-line="992">        return <span style="color: #ffb86c;">lhs</span>.<span style="color: #50fa7b;">second</span> &lt; <span style="color: #ffb86c;">rhs</span>.<span style="color: #50fa7b;">second</span>;
</span><span class="athl-line" data-athl-line="993">    });
</span><span class="athl-line" data-athl-line="994">
</span><span class="athl-line" data-athl-line="995">// Notice the syntax of the lambda expression,
</span><span class="athl-line" data-athl-line="996">// [] in the lambda is used to &quot;capture&quot; variables
</span><span class="athl-line" data-athl-line="997">// The &quot;Capture List&quot; defines what from the outside of the lambda should be available inside the function body and how.
</span><span class="athl-line" data-athl-line="998">// It can be either:
</span><span class="athl-line" data-athl-line="999">//     1. a value : [x]
</span><span class="athl-line" data-athl-line="1000">//     2. a reference : [&amp;x]
</span><span class="athl-line" data-athl-line="1001">//     3. any variable currently in scope by reference [&amp;]
</span><span class="athl-line" data-athl-line="1002">//     4. same as 3, but by value [=]
</span><span class="athl-line" data-athl-line="1003">// Example:
</span><span class="athl-line" data-athl-line="1004">
</span><span class="athl-line" data-athl-line="1005"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span>vector<span style="color: #f8f8f2;">&lt;</span>int<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">dog_ids</span>;
</span><span class="athl-line" data-athl-line="1006">// number_of_dogs = 3;
</span><span class="athl-line" data-athl-line="1007">for (int <span style="color: #ffb86c;">i</span> = 0; <span style="color: #ffb86c;">i</span> &lt; 3; <span style="color: #ffb86c;">i</span>++) {
</span><span class="athl-line" data-athl-line="1008">    <span style="color: #ffb86c;">dog_ids</span>.<span style="color: #8be9fd;">push_back</span>(<span style="color: #ffb86c;">i</span>);
</span><span class="athl-line" data-athl-line="1009">}
</span><span class="athl-line" data-athl-line="1010">
</span><span class="athl-line" data-athl-line="1011">int <span style="color: #ffb86c;">weight</span>[3] = {30, 50, 10};
</span><span class="athl-line" data-athl-line="1012">
</span><span class="athl-line" data-athl-line="1013">// Say you want to sort dog_ids according to the dogs&#39; weights
</span><span class="athl-line" data-athl-line="1014">// So dog_ids should in the end become: [2, 0, 1]
</span><span class="athl-line" data-athl-line="1015">
</span><span class="athl-line" data-athl-line="1016">// Here&#39;s where lambda expressions come in handy
</span><span class="athl-line" data-athl-line="1017">
</span><span class="athl-line" data-athl-line="1018"><span style="color: #8be9fd;">sort</span>(<span style="color: #ffb86c;">dog_ids</span>.<span style="color: #8be9fd;">begin</span>(), <span style="color: #ffb86c;">dog_ids</span>.<span style="color: #8be9fd;">end</span>(), [&amp;<span style="color: #ffb86c;">weight</span>](const int <span style="color: #ffb86c;">&amp;<span style="color: #ffb86c;">lhs</span></span>, const int <span style="color: #ffb86c;">&amp;<span style="color: #ffb86c;">rhs</span></span>) {
</span><span class="athl-line" data-athl-line="1019">        return <span style="color: #ffb86c;">weight</span>[<span style="color: #ffb86c;">lhs</span>] &lt; <span style="color: #ffb86c;">weight</span>[<span style="color: #ffb86c;">rhs</span>];
</span><span class="athl-line" data-athl-line="1020">    });
</span><span class="athl-line" data-athl-line="1021">// Note we captured &quot;weight&quot; by reference in the above example.
</span><span class="athl-line" data-athl-line="1022">// More on Lambdas in C++ : https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11
</span><span class="athl-line" data-athl-line="1023">
</span><span class="athl-line" data-athl-line="1024">///////////////////////////////
</span><span class="athl-line" data-athl-line="1025">// Range For (C++11 and above)
</span><span class="athl-line" data-athl-line="1026">///////////////////////////////
</span><span class="athl-line" data-athl-line="1027">
</span><span class="athl-line" data-athl-line="1028">// You can use a range for loop to iterate over a container
</span><span class="athl-line" data-athl-line="1029">int <span style="color: #ffb86c;">arr</span>[] = {1, 10, 3};
</span><span class="athl-line" data-athl-line="1030">
</span><span class="athl-line" data-athl-line="1031">for (int <span style="color: #ffb86c;">elem</span>: <span style="color: #ffb86c;">arr</span>) {
</span><span class="athl-line" data-athl-line="1032">    <span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">elem</span> &lt;&lt; <span style="color: #ffb86c;">endl</span>;
</span><span class="athl-line" data-athl-line="1033">}
</span><span class="athl-line" data-athl-line="1034">
</span><span class="athl-line" data-athl-line="1035">// You can use &quot;auto&quot; and not worry about the type of the elements of the container
</span><span class="athl-line" data-athl-line="1036">// For example:
</span><span class="athl-line" data-athl-line="1037">
</span><span class="athl-line" data-athl-line="1038">for (<span style="color: #8be9fd;">auto</span> <span style="color: #ffb86c;">elem</span>: <span style="color: #ffb86c;">arr</span>) {
</span><span class="athl-line" data-athl-line="1039">    // Do something with each element of arr
</span><span class="athl-line" data-athl-line="1040">}
</span><span class="athl-line" data-athl-line="1041">
</span><span class="athl-line" data-athl-line="1042">/////////////////////
</span><span class="athl-line" data-athl-line="1043">// Fun stuff
</span><span class="athl-line" data-athl-line="1044">/////////////////////
</span><span class="athl-line" data-athl-line="1045">
</span><span class="athl-line" data-athl-line="1046">// Aspects of C++ that may be surprising to newcomers (and even some veterans).
</span><span class="athl-line" data-athl-line="1047">// This section is, unfortunately, wildly incomplete; C++ is one of the easiest
</span><span class="athl-line" data-athl-line="1048">// languages with which to shoot yourself in the foot.
</span><span class="athl-line" data-athl-line="1049">
</span><span class="athl-line" data-athl-line="1050">// You can override private methods!
</span><span class="athl-line" data-athl-line="1051"><span style="color: #ff79c6;">class</span> Foo {
</span><span class="athl-line" data-athl-line="1052">    <span style="color: #ff79c6;">virtual</span> void <span style="color: #50fa7b;">bar</span>();
</span><span class="athl-line" data-athl-line="1053">};
</span><span class="athl-line" data-athl-line="1054"><span style="color: #ff79c6;">class</span> FooSub : <span style="color: #ff79c6;">public</span> Foo {
</span><span class="athl-line" data-athl-line="1055">    <span style="color: #ff79c6;">virtual</span> void <span style="color: #50fa7b;">bar</span>();  // Overrides Foo::bar!
</span><span class="athl-line" data-athl-line="1056">};
</span><span class="athl-line" data-athl-line="1057">
</span><span class="athl-line" data-athl-line="1058">
</span><span class="athl-line" data-athl-line="1059">// 0 == false == NULL (most of the time)!
</span><span class="athl-line" data-athl-line="1060">bool* <span style="color: #ffb86c;">pt</span> = <span style="color: #ff79c6;">new</span> bool;
</span><span class="athl-line" data-athl-line="1061">*<span style="color: #ffb86c;">pt</span> = 0; // Sets the value points by &#39;pt&#39; to false.
</span><span class="athl-line" data-athl-line="1062"><span style="color: #ffb86c;">pt</span> = 0;  // Sets &#39;pt&#39; to the null pointer. Both lines compile without warnings.
</span><span class="athl-line" data-athl-line="1063">
</span><span class="athl-line" data-athl-line="1064">// nullptr is supposed to fix some of that issue:
</span><span class="athl-line" data-athl-line="1065">int* <span style="color: #ffb86c;">pt2</span> = <span style="color: #ff79c6;">new</span> int;
</span><span class="athl-line" data-athl-line="1066">*<span style="color: #ffb86c;">pt2</span> = <span style="color: #bd93f9;">nullptr</span>; // Doesn&#39;t compile
</span><span class="athl-line" data-athl-line="1067"><span style="color: #ffb86c;">pt2</span> = <span style="color: #bd93f9;">nullptr</span>;  // Sets pt2 to null.
</span><span class="athl-line" data-athl-line="1068">
</span><span class="athl-line" data-athl-line="1069">// There is an exception made for bools.
</span><span class="athl-line" data-athl-line="1070">// This is to allow you to test for null pointers with if(!ptr),
</span><span class="athl-line" data-athl-line="1071">// but as a consequence you can assign nullptr to a bool directly!
</span><span class="athl-line" data-athl-line="1072">*<span style="color: #ffb86c;">pt</span> = <span style="color: #bd93f9;">nullptr</span>;  // This still compiles, even though &#39;*pt&#39; is a bool!
</span><span class="athl-line" data-athl-line="1073">
</span><span class="athl-line" data-athl-line="1074">
</span><span class="athl-line" data-athl-line="1075">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!
</span><span class="athl-line" data-athl-line="1076">// Calls Foo::Foo(const Foo&amp;) or some variant (see move semantics) copy
</span><span class="athl-line" data-athl-line="1077">// constructor.
</span><span class="athl-line" data-athl-line="1078">Foo <span style="color: #ffb86c;">f2</span>;
</span><span class="athl-line" data-athl-line="1079">Foo <span style="color: #ffb86c;">f1</span> = <span style="color: #ffb86c;">f2</span>;
</span><span class="athl-line" data-athl-line="1080">
</span><span class="athl-line" data-athl-line="1081">// Calls Foo::Foo(const Foo&amp;) or variant, but only copies the &#39;Foo&#39; part of
</span><span class="athl-line" data-athl-line="1082">// &#39;fooSub&#39;. Any extra members of &#39;fooSub&#39; are discarded. This sometimes
</span><span class="athl-line" data-athl-line="1083">// horrifying behavior is called &quot;object slicing.&quot;
</span><span class="athl-line" data-athl-line="1084">FooSub <span style="color: #ffb86c;">fooSub</span>;
</span><span class="athl-line" data-athl-line="1085">Foo <span style="color: #ffb86c;">f1</span> = <span style="color: #ffb86c;">fooSub</span>;
</span><span class="athl-line" data-athl-line="1086">
</span><span class="athl-line" data-athl-line="1087">// Calls Foo::operator=(Foo&amp;) or variant.
</span><span class="athl-line" data-athl-line="1088">Foo <span style="color: #ffb86c;">f1</span>;
</span><span class="athl-line" data-athl-line="1089"><span style="color: #ffb86c;">f1</span> = <span style="color: #ffb86c;">f2</span>;
</span><span class="athl-line" data-athl-line="1090">
</span><span class="athl-line" data-athl-line="1091">
</span><span class="athl-line" data-athl-line="1092">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="1093">// Tuples (C++11 and above)
</span><span class="athl-line" data-athl-line="1094">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="1095">
</span><span class="athl-line" data-athl-line="1096">#include&lt;tuple&gt;
</span><span class="athl-line" data-athl-line="1097">
</span><span class="athl-line" data-athl-line="1098">// Conceptually, Tuples are similar to old data structures (C-like structs)
</span><span class="athl-line" data-athl-line="1099">// but instead of having named data members,
</span><span class="athl-line" data-athl-line="1100">// its elements are accessed by their order in the tuple.
</span><span class="athl-line" data-athl-line="1101">
</span><span class="athl-line" data-athl-line="1102">// We start with constructing a tuple.
</span><span class="athl-line" data-athl-line="1103">// Packing values into tuple
</span><span class="athl-line" data-athl-line="1104"><span style="color: #8be9fd;">auto</span> <span style="color: #ffb86c;">first</span> = <span style="color: #8be9fd;">make_tuple</span>(10, &#39;A&#39;);
</span><span class="athl-line" data-athl-line="1105">const int <span style="color: #ffb86c;">maxN</span> = 1e9;
</span><span class="athl-line" data-athl-line="1106">const int <span style="color: #ffb86c;">maxL</span> = 15;
</span><span class="athl-line" data-athl-line="1107"><span style="color: #8be9fd;">auto</span> <span style="color: #ffb86c;">second</span> = <span style="color: #8be9fd;">make_tuple</span>(<span style="color: #ffb86c;">maxN</span>, <span style="color: #ffb86c;">maxL</span>);
</span><span class="athl-line" data-athl-line="1108">
</span><span class="athl-line" data-athl-line="1109">// Printing elements of &#39;first&#39; tuple
</span><span class="athl-line" data-athl-line="1110"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>0<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">first</span>) &lt;&lt; &quot; &quot; &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>1<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">first</span>) &lt;&lt; &#39;\n&#39;; //prints : 10 A
</span><span class="athl-line" data-athl-line="1111">
</span><span class="athl-line" data-athl-line="1112">// Printing elements of &#39;second&#39; tuple
</span><span class="athl-line" data-athl-line="1113"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>0<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">second</span>) &lt;&lt; &quot; &quot; &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>1<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">second</span>) &lt;&lt; &#39;\n&#39;; // prints: 1000000000 15
</span><span class="athl-line" data-athl-line="1114">
</span><span class="athl-line" data-athl-line="1115">// Unpacking tuple into variables
</span><span class="athl-line" data-athl-line="1116">
</span><span class="athl-line" data-athl-line="1117">int <span style="color: #ffb86c;">first_int</span>;
</span><span class="athl-line" data-athl-line="1118">char <span style="color: #ffb86c;">first_char</span>;
</span><span class="athl-line" data-athl-line="1119"><span style="color: #8be9fd;">tie</span>(<span style="color: #ffb86c;">first_int</span>, <span style="color: #ffb86c;">first_char</span>) = <span style="color: #ffb86c;">first</span>;
</span><span class="athl-line" data-athl-line="1120"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #ffb86c;">first_int</span> &lt;&lt; &quot; &quot; &lt;&lt; <span style="color: #ffb86c;">first_char</span> &lt;&lt; &#39;\n&#39;;  // prints : 10 A
</span><span class="athl-line" data-athl-line="1121">
</span><span class="athl-line" data-athl-line="1122">// We can also create tuple like this.
</span><span class="athl-line" data-athl-line="1123">
</span><span class="athl-line" data-athl-line="1124">tuple<span style="color: #f8f8f2;">&lt;</span>int, char, double<span style="color: #f8f8f2;">&gt;</span> <span style="color: #ffb86c;">third</span>(11, &#39;A&#39;, 3.14141);
</span><span class="athl-line" data-athl-line="1125">// tuple_size returns number of elements in a tuple (as a constexpr)
</span><span class="athl-line" data-athl-line="1126">
</span><span class="athl-line" data-athl-line="1127"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; tuple_size<span style="color: #f8f8f2;">&lt;</span><span style="color: #ff79c6;">decltype</span>(<span style="color: #ffb86c;">third</span>)<span style="color: #f8f8f2;">&gt;</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">value</span> &lt;&lt; &#39;\n&#39;; // prints: 3
</span><span class="athl-line" data-athl-line="1128">
</span><span class="athl-line" data-athl-line="1129">// tuple_cat concatenates the elements of all the tuples in the same order.
</span><span class="athl-line" data-athl-line="1130">
</span><span class="athl-line" data-athl-line="1131"><span style="color: #8be9fd;">auto</span> <span style="color: #ffb86c;">concatenated_tuple</span> = <span style="color: #8be9fd;">tuple_cat</span>(<span style="color: #ffb86c;">first</span>, <span style="color: #ffb86c;">second</span>, <span style="color: #ffb86c;">third</span>);
</span><span class="athl-line" data-athl-line="1132">// concatenated_tuple becomes = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39;, 3.14141)
</span><span class="athl-line" data-athl-line="1133">
</span><span class="athl-line" data-athl-line="1134"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>0<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">concatenated_tuple</span>) &lt;&lt; &#39;\n&#39;; // prints: 10
</span><span class="athl-line" data-athl-line="1135"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>3<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">concatenated_tuple</span>) &lt;&lt; &#39;\n&#39;; // prints: 15
</span><span class="athl-line" data-athl-line="1136"><span style="color: #a4ffff;">std</span><span style="color: #f8f8f2;">::</span><span style="color: #ffb86c;">cout</span> &lt;&lt; <span style="color: #50fa7b;">get</span><span style="color: #f8f8f2;">&lt;</span>5<span style="color: #f8f8f2;">&gt;</span>(<span style="color: #ffb86c;">concatenated_tuple</span>) &lt;&lt; &#39;\n&#39;; // prints: &#39;A&#39;
</span><span class="athl-line" data-athl-line="1137">
</span><span class="athl-line" data-athl-line="1138">
</span><span class="athl-line" data-athl-line="1139">///////////////////////////////////
</span><span class="athl-line" data-athl-line="1140">// Logical and Bitwise operators
</span><span class="athl-line" data-athl-line="1141">//////////////////////////////////
</span><span class="athl-line" data-athl-line="1142">
</span><span class="athl-line" data-athl-line="1143">// Most of the operators in C++ are same as in other languages
</span><span class="athl-line" data-athl-line="1144">
</span><span class="athl-line" data-athl-line="1145">// Logical operators
</span><span class="athl-line" data-athl-line="1146">
</span><span class="athl-line" data-athl-line="1147">// C++ uses Short-circuit evaluation for boolean expressions, i.e, the second argument is executed or
</span><span class="athl-line" data-athl-line="1148">// evaluated only if the first argument does not suffice to determine the value of the expression
</span><span class="athl-line" data-athl-line="1149">
</span><span class="athl-line" data-athl-line="1150"><span style="color: #bd93f9;">true</span> &amp;&amp; <span style="color: #bd93f9;">false</span> // Performs **logical and** to yield false
</span><span class="athl-line" data-athl-line="1151"><span style="color: #ffb86c;">true</span> || <span style="color: #bd93f9;">false</span> // Performs **logical or** to yield true
</span><span class="athl-line" data-athl-line="1152">! <span style="color: #bd93f9;">true</span>        // Performs **logical not** to yield false
</span><span class="athl-line" data-athl-line="1153">
</span><span class="athl-line" data-athl-line="1154">// Instead of using symbols equivalent keywords can be used
</span><span class="athl-line" data-athl-line="1155"><span style="color: #ffb86c;">true</span> <span style="color: #ff79c6;">and</span> <span style="color: #bd93f9;">false</span> // Performs **logical and** to yield false
</span><span class="athl-line" data-athl-line="1156"><span style="color: #ffb86c;">true</span> <span style="color: #ff79c6;">or</span> <span style="color: #bd93f9;">false</span>  // Performs **logical or** to yield true
</span><span class="athl-line" data-athl-line="1157"><span style="color: #ff79c6;">not</span> <span style="color: #bd93f9;">true</span>       // Performs **logical not** to yield false
</span><span class="athl-line" data-athl-line="1158">
</span><span class="athl-line" data-athl-line="1159">// Bitwise operators
</span><span class="athl-line" data-athl-line="1160">
</span><span class="athl-line" data-athl-line="1161">// **&lt;&lt;** Left Shift Operator
</span><span class="athl-line" data-athl-line="1162">// &lt;&lt; shifts bits to the left
</span><span class="athl-line" data-athl-line="1163">4 &lt;&lt; 1 // Shifts bits of 4 to left by 1 to give 8
</span><span class="athl-line" data-athl-line="1164">// x &lt;&lt; n can be thought as x * 2^n
</span><span class="athl-line" data-athl-line="1165">
</span><span class="athl-line" data-athl-line="1166">
</span><span class="athl-line" data-athl-line="1167">// **&gt;&gt;** Right Shift Operator
</span><span class="athl-line" data-athl-line="1168">// &gt;&gt; shifts bits to the right
</span><span class="athl-line" data-athl-line="1169">4 &gt;&gt; 1 // Shifts bits of 4 to right by 1 to give 2
</span><span class="athl-line" data-athl-line="1170">// x &gt;&gt; n can be thought as x / 2^n
</span><span class="athl-line" data-athl-line="1171">
</span><span class="athl-line" data-athl-line="1172">~4    // Performs a bitwise not
</span><span class="athl-line" data-athl-line="1173">4 | 3 // Performs bitwise or
</span><span class="athl-line" data-athl-line="1174">4 &amp; 3 // Performs bitwise and
</span><span class="athl-line" data-athl-line="1175">4 ^ 3 // Performs bitwise xor
</span><span class="athl-line" data-athl-line="1176">
</span><span class="athl-line" data-athl-line="1177">// Equivalent keywords are
</span><span class="athl-line" data-athl-line="1178"><span style="color: #ff79c6;">compl</span> 4    // Performs a bitwise not
</span><span class="athl-line" data-athl-line="1179">4 <span style="color: #ff79c6;">bitor</span> 3  // Performs bitwise or
</span><span class="athl-line" data-athl-line="1180">4 <span style="color: #ff79c6;">bitand</span> 3 // Performs bitwise and
</span><span class="athl-line" data-athl-line="1181">4 <span style="color: #ff79c6;">xor</span> 3    // Performs bitwise xor
</span></code></pre>
</body>
</html>