<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>cpp - catppuccin_frappe - Autumnus</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            font-family: 'JetBrains Mono', monospace;
            line-height: 1.5;
        }
        pre {
            font-size: 15px;
            margin: 20px;
            padding: 50px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
<pre class="athl" style="color: #c6d0f5; background-color: #303446;"><code class="language-c++" translate="no" tabindex="0"><span class="athl-line" data-athl-line="1">//////////////////
</span><span class="athl-line" data-athl-line="2">// Comparison to C
</span><span class="athl-line" data-athl-line="3">//////////////////
</span><span class="athl-line" data-athl-line="4">
</span><span class="athl-line" data-athl-line="5">// C++ is almost a superset of C and shares its basic syntax for
</span><span class="athl-line" data-athl-line="6">// variable declarations, primitive types, and functions.
</span><span class="athl-line" data-athl-line="7">
</span><span class="athl-line" data-athl-line="8">// Just like in C, your program&#39;s entry point is a function called
</span><span class="athl-line" data-athl-line="9">// main with an integer return type.
</span><span class="athl-line" data-athl-line="10">// This value serves as the program&#39;s exit status.
</span><span class="athl-line" data-athl-line="11">// See https://en.wikipedia.org/wiki/Exit_status for more information.
</span><span class="athl-line" data-athl-line="12">int main(int argc, char** argv)
</span><span class="athl-line" data-athl-line="13">{
</span><span class="athl-line" data-athl-line="14">    // Command line arguments are passed in by argc and argv in the same way
</span><span class="athl-line" data-athl-line="15">    // they are in C.
</span><span class="athl-line" data-athl-line="16">    // argc indicates the number of arguments,
</span><span class="athl-line" data-athl-line="17">    // and argv is an array of C-style strings (char*)
</span><span class="athl-line" data-athl-line="18">    // representing the arguments.
</span><span class="athl-line" data-athl-line="19">    // The first argument is the name by which the program was called.
</span><span class="athl-line" data-athl-line="20">    // argc and argv can be omitted if you do not care about arguments,
</span><span class="athl-line" data-athl-line="21">    // giving the function signature of int main()
</span><span class="athl-line" data-athl-line="22">
</span><span class="athl-line" data-athl-line="23">    // An exit status of 0 indicates success.
</span><span class="athl-line" data-athl-line="24">    return 0;
</span><span class="athl-line" data-athl-line="25">}
</span><span class="athl-line" data-athl-line="26">
</span><span class="athl-line" data-athl-line="27">// However, C++ varies in some of the following ways:
</span><span class="athl-line" data-athl-line="28">
</span><span class="athl-line" data-athl-line="29">// In C++, character literals are chars, therefore the size is 1
</span><span class="athl-line" data-athl-line="30">sizeof(&#39;c&#39;) == sizeof(char)
</span><span class="athl-line" data-athl-line="31">
</span><span class="athl-line" data-athl-line="32">// In C, character literals are ints, therefore the size is 4
</span><span class="athl-line" data-athl-line="33">sizeof(&#39;c&#39;) == sizeof(int)
</span><span class="athl-line" data-athl-line="34">
</span><span class="athl-line" data-athl-line="35">
</span><span class="athl-line" data-athl-line="36">// C++ has strict prototyping
</span><span class="athl-line" data-athl-line="37">void func(); // function which accepts no arguments
</span><span class="athl-line" data-athl-line="38">void func(void); // same as earlier
</span><span class="athl-line" data-athl-line="39">
</span><span class="athl-line" data-athl-line="40">// In C
</span><span class="athl-line" data-athl-line="41">void func(); // function which may accept any number of arguments with unknown type
</span><span class="athl-line" data-athl-line="42">void func(void); // function which accepts no arguments
</span><span class="athl-line" data-athl-line="43">
</span><span class="athl-line" data-athl-line="44">// Use nullptr instead of NULL in C++
</span><span class="athl-line" data-athl-line="45">int* ip = <span style="color: #ef9f76;">nullptr</span>;
</span><span class="athl-line" data-athl-line="46">
</span><span class="athl-line" data-athl-line="47">// Most C standard headers are available in C++.
</span><span class="athl-line" data-athl-line="48">// C headers generally end with .h, while
</span><span class="athl-line" data-athl-line="49">// C++ headers are prefixed with &quot;c&quot; and have no &quot;.h&quot; suffix.
</span><span class="athl-line" data-athl-line="50">
</span><span class="athl-line" data-athl-line="51">// The C++ standard version:
</span><span class="athl-line" data-athl-line="52">#include &lt;cstdio&gt;
</span><span class="athl-line" data-athl-line="53">
</span><span class="athl-line" data-athl-line="54">// The C standard version:
</span><span class="athl-line" data-athl-line="55">#include &lt;stdio.h&gt;
</span><span class="athl-line" data-athl-line="56">
</span><span class="athl-line" data-athl-line="57">int main()
</span><span class="athl-line" data-athl-line="58">{
</span><span class="athl-line" data-athl-line="59">    printf(&quot;Hello, world!\n&quot;);
</span><span class="athl-line" data-athl-line="60">    return 0;
</span><span class="athl-line" data-athl-line="61">}
</span><span class="athl-line" data-athl-line="62">
</span><span class="athl-line" data-athl-line="63">///////////////////////
</span><span class="athl-line" data-athl-line="64">// Function overloading
</span><span class="athl-line" data-athl-line="65">///////////////////////
</span><span class="athl-line" data-athl-line="66">
</span><span class="athl-line" data-athl-line="67">// C++ supports function overloading
</span><span class="athl-line" data-athl-line="68">// provided each function takes different parameters.
</span><span class="athl-line" data-athl-line="69">
</span><span class="athl-line" data-athl-line="70">void print(char const* myString)
</span><span class="athl-line" data-athl-line="71">{
</span><span class="athl-line" data-athl-line="72">    printf(&quot;String %s\n&quot;, myString);
</span><span class="athl-line" data-athl-line="73">}
</span><span class="athl-line" data-athl-line="74">
</span><span class="athl-line" data-athl-line="75">void print(int myInt)
</span><span class="athl-line" data-athl-line="76">{
</span><span class="athl-line" data-athl-line="77">    printf(&quot;My int is %d\n&quot;, myInt);
</span><span class="athl-line" data-athl-line="78">}
</span><span class="athl-line" data-athl-line="79">
</span><span class="athl-line" data-athl-line="80">int main()
</span><span class="athl-line" data-athl-line="81">{
</span><span class="athl-line" data-athl-line="82">    print(&quot;Hello&quot;); // Resolves to void print(const char*)
</span><span class="athl-line" data-athl-line="83">    print(15); // Resolves to void print(int)
</span><span class="athl-line" data-athl-line="84">}
</span><span class="athl-line" data-athl-line="85">
</span><span class="athl-line" data-athl-line="86">/////////////////////////////
</span><span class="athl-line" data-athl-line="87">// Default function arguments
</span><span class="athl-line" data-athl-line="88">/////////////////////////////
</span><span class="athl-line" data-athl-line="89">
</span><span class="athl-line" data-athl-line="90">// You can provide default arguments for a function
</span><span class="athl-line" data-athl-line="91">// if they are not provided by the caller.
</span><span class="athl-line" data-athl-line="92">
</span><span class="athl-line" data-athl-line="93">void doSomethingWithInts(int a = 1, int b = 4)
</span><span class="athl-line" data-athl-line="94">{
</span><span class="athl-line" data-athl-line="95">    // Do something with the ints here
</span><span class="athl-line" data-athl-line="96">}
</span><span class="athl-line" data-athl-line="97">
</span><span class="athl-line" data-athl-line="98">int main()
</span><span class="athl-line" data-athl-line="99">{
</span><span class="athl-line" data-athl-line="100">    doSomethingWithInts();      // a = 1,  b = 4
</span><span class="athl-line" data-athl-line="101">    doSomethingWithInts(20);    // a = 20, b = 4
</span><span class="athl-line" data-athl-line="102">    doSomethingWithInts(20, 5); // a = 20, b = 5
</span><span class="athl-line" data-athl-line="103">}
</span><span class="athl-line" data-athl-line="104">
</span><span class="athl-line" data-athl-line="105">// Default arguments must be at the end of the arguments list.
</span><span class="athl-line" data-athl-line="106">
</span><span class="athl-line" data-athl-line="107">void invalidDeclaration(int a = 1, int b) // Error!
</span><span class="athl-line" data-athl-line="108">{
</span><span class="athl-line" data-athl-line="109">}
</span><span class="athl-line" data-athl-line="110">
</span><span class="athl-line" data-athl-line="111">
</span><span class="athl-line" data-athl-line="112">/////////////
</span><span class="athl-line" data-athl-line="113">// Namespaces
</span><span class="athl-line" data-athl-line="114">/////////////
</span><span class="athl-line" data-athl-line="115">
</span><span class="athl-line" data-athl-line="116">// Namespaces provide separate scopes for variable, function,
</span><span class="athl-line" data-athl-line="117">// and other declarations.
</span><span class="athl-line" data-athl-line="118">// Namespaces can be nested.
</span><span class="athl-line" data-athl-line="119">
</span><span class="athl-line" data-athl-line="120"><span style="color: #ca9ee6;">namespace</span> <span style="color: #e5c890;">First</span> {
</span><span class="athl-line" data-athl-line="121">    <span style="color: #ca9ee6;">namespace</span> <span style="color: #e5c890;">Nested</span> {
</span><span class="athl-line" data-athl-line="122">        void foo()
</span><span class="athl-line" data-athl-line="123">        {
</span><span class="athl-line" data-athl-line="124">            printf(&quot;This is First::Nested::foo\n&quot;);
</span><span class="athl-line" data-athl-line="125">        }
</span><span class="athl-line" data-athl-line="126">    } // end namespace Nested
</span><span class="athl-line" data-athl-line="127">} // end namespace First
</span><span class="athl-line" data-athl-line="128">
</span><span class="athl-line" data-athl-line="129"><span style="color: #ca9ee6;">namespace</span> <span style="color: #e5c890;">Second</span> {
</span><span class="athl-line" data-athl-line="130">    void foo()
</span><span class="athl-line" data-athl-line="131">    {
</span><span class="athl-line" data-athl-line="132">        printf(&quot;This is Second::foo\n&quot;);
</span><span class="athl-line" data-athl-line="133">    }
</span><span class="athl-line" data-athl-line="134">    void bar()
</span><span class="athl-line" data-athl-line="135">    {
</span><span class="athl-line" data-athl-line="136">        printf(&quot;This is Second::bar\n&quot;);
</span><span class="athl-line" data-athl-line="137">    }
</span><span class="athl-line" data-athl-line="138">}
</span><span class="athl-line" data-athl-line="139">
</span><span class="athl-line" data-athl-line="140">void foo()
</span><span class="athl-line" data-athl-line="141">{
</span><span class="athl-line" data-athl-line="142">    printf(&quot;This is global foo\n&quot;);
</span><span class="athl-line" data-athl-line="143">}
</span><span class="athl-line" data-athl-line="144">
</span><span class="athl-line" data-athl-line="145">int main()
</span><span class="athl-line" data-athl-line="146">{
</span><span class="athl-line" data-athl-line="147">    // Includes all symbols from namespace Second into the current scope. Note
</span><span class="athl-line" data-athl-line="148">    // that while bar() works, simply using foo() no longer works, since it is
</span><span class="athl-line" data-athl-line="149">    // now ambiguous whether we&#39;re calling the foo in namespace Second or the
</span><span class="athl-line" data-athl-line="150">    // top level.
</span><span class="athl-line" data-athl-line="151">    <span style="color: #ca9ee6;">using</span> <span style="color: #ca9ee6;">namespace</span> Second;
</span><span class="athl-line" data-athl-line="152">
</span><span class="athl-line" data-athl-line="153">    bar(); // prints &quot;This is Second::bar&quot;
</span><span class="athl-line" data-athl-line="154">    <span style="color: #e5c890;">Second</span>::<span style="color: #8caaee;">foo</span>(); // prints &quot;This is Second::foo&quot;
</span><span class="athl-line" data-athl-line="155">    <span style="color: #e5c890;">First</span>::<span style="color: #e5c890;">Nested</span>::foo(); // prints &quot;This is First::Nested::foo&quot;
</span><span class="athl-line" data-athl-line="156">    ::<span style="color: #8caaee;">foo</span>(); // prints &quot;This is global foo&quot;
</span><span class="athl-line" data-athl-line="157">}
</span><span class="athl-line" data-athl-line="158">
</span><span class="athl-line" data-athl-line="159">///////////////
</span><span class="athl-line" data-athl-line="160">// Input/Output
</span><span class="athl-line" data-athl-line="161">///////////////
</span><span class="athl-line" data-athl-line="162">
</span><span class="athl-line" data-athl-line="163">// C++ input and output uses streams
</span><span class="athl-line" data-athl-line="164">// cin, cout, and cerr represent stdin, stdout, and stderr.
</span><span class="athl-line" data-athl-line="165">// &lt;&lt; is the insertion operator and &gt;&gt; is the extraction operator.
</span><span class="athl-line" data-athl-line="166">
</span><span class="athl-line" data-athl-line="167">#include &lt;iostream&gt; // Include for I/O streams
</span><span class="athl-line" data-athl-line="168">
</span><span class="athl-line" data-athl-line="169">int main()
</span><span class="athl-line" data-athl-line="170">{
</span><span class="athl-line" data-athl-line="171">    int myInt;
</span><span class="athl-line" data-athl-line="172">
</span><span class="athl-line" data-athl-line="173">    // Prints to stdout (or terminal/screen)
</span><span class="athl-line" data-athl-line="174">    // std::cout referring the access to the std namespace
</span><span class="athl-line" data-athl-line="175">    std::cout &lt;&lt; &quot;Enter your favorite number:\n&quot;;
</span><span class="athl-line" data-athl-line="176">    // Takes in input
</span><span class="athl-line" data-athl-line="177">    std::cin &gt;&gt; myInt;
</span><span class="athl-line" data-athl-line="178">
</span><span class="athl-line" data-athl-line="179">    // cout can also be formatted
</span><span class="athl-line" data-athl-line="180">    std::cout &lt;&lt; &quot;Your favorite number is &quot; &lt;&lt; myInt &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="181">    // prints &quot;Your favorite number is &lt;myInt&gt;&quot;
</span><span class="athl-line" data-athl-line="182">
</span><span class="athl-line" data-athl-line="183">    std::cerr &lt;&lt; &quot;Used for error messages&quot;;
</span><span class="athl-line" data-athl-line="184">
</span><span class="athl-line" data-athl-line="185">    // flush string stream buffer with new line
</span><span class="athl-line" data-athl-line="186">    std::cout &lt;&lt; &quot;I flushed it away&quot; &lt;&lt; std::endl;
</span><span class="athl-line" data-athl-line="187">}
</span><span class="athl-line" data-athl-line="188">
</span><span class="athl-line" data-athl-line="189">//////////
</span><span class="athl-line" data-athl-line="190">// Strings
</span><span class="athl-line" data-athl-line="191">//////////
</span><span class="athl-line" data-athl-line="192">
</span><span class="athl-line" data-athl-line="193">// Strings in C++ are objects and have many member functions
</span><span class="athl-line" data-athl-line="194">#include &lt;string&gt;
</span><span class="athl-line" data-athl-line="195">
</span><span class="athl-line" data-athl-line="196">std::string myString = &quot;Hello&quot;;
</span><span class="athl-line" data-athl-line="197">std::string myOtherString = &quot; World&quot;;
</span><span class="athl-line" data-athl-line="198">
</span><span class="athl-line" data-athl-line="199">// + is used for concatenation.
</span><span class="athl-line" data-athl-line="200">std::cout &lt;&lt; myString + myOtherString; // &quot;Hello World&quot;
</span><span class="athl-line" data-athl-line="201">
</span><span class="athl-line" data-athl-line="202">std::cout &lt;&lt; myString + &quot; You&quot;; // &quot;Hello You&quot;
</span><span class="athl-line" data-athl-line="203">
</span><span class="athl-line" data-athl-line="204">// C++ string length can be found from either string::length() or string::size()
</span><span class="athl-line" data-athl-line="205">cout &lt;&lt; myString.length() + myOtherString.size(); // Outputs 11 (= 5 + 6).
</span><span class="athl-line" data-athl-line="206">
</span><span class="athl-line" data-athl-line="207">// C++ strings are mutable.
</span><span class="athl-line" data-athl-line="208">myString.append(&quot; Dog&quot;);
</span><span class="athl-line" data-athl-line="209">std::cout &lt;&lt; myString; // &quot;Hello Dog&quot;
</span><span class="athl-line" data-athl-line="210">
</span><span class="athl-line" data-athl-line="211">// C++ can handle C-style strings with related functions using cstrings
</span><span class="athl-line" data-athl-line="212">#include &lt;cstring&gt;
</span><span class="athl-line" data-athl-line="213">
</span><span class="athl-line" data-athl-line="214">char myOldString[10] = &quot;Hello CPP&quot;;
</span><span class="athl-line" data-athl-line="215">cout &lt;&lt; myOldString;
</span><span class="athl-line" data-athl-line="216">cout &lt;&lt; &quot;Length = &quot; &lt;&lt; strlen(myOldString); // Length = 9
</span><span class="athl-line" data-athl-line="217">
</span><span class="athl-line" data-athl-line="218">/////////////
</span><span class="athl-line" data-athl-line="219">// References
</span><span class="athl-line" data-athl-line="220">/////////////
</span><span class="athl-line" data-athl-line="221">
</span><span class="athl-line" data-athl-line="222">// In addition to pointers like the ones in C,
</span><span class="athl-line" data-athl-line="223">// C++ has _references_.
</span><span class="athl-line" data-athl-line="224">// These are pointer types that cannot be reassigned once set
</span><span class="athl-line" data-athl-line="225">// and cannot be null.
</span><span class="athl-line" data-athl-line="226">// They also have the same syntax as the variable itself:
</span><span class="athl-line" data-athl-line="227">// No * is needed for dereferencing and
</span><span class="athl-line" data-athl-line="228">// &amp; (address of) is not used for assignment.
</span><span class="athl-line" data-athl-line="229">
</span><span class="athl-line" data-athl-line="230">std::string foo = &quot;I am foo&quot;;
</span><span class="athl-line" data-athl-line="231">std::string bar = &quot;I am bar&quot;;
</span><span class="athl-line" data-athl-line="232">
</span><span class="athl-line" data-athl-line="233">std::string&amp; fooRef = foo; // This creates a reference to foo.
</span><span class="athl-line" data-athl-line="234">fooRef += &quot;. Hi!&quot;; // Modifies foo through the reference
</span><span class="athl-line" data-athl-line="235">std::cout &lt;&lt; fooRef; // Prints &quot;I am foo. Hi!&quot;
</span><span class="athl-line" data-athl-line="236">
</span><span class="athl-line" data-athl-line="237">std::cout &lt;&lt; &amp;fooRef &lt;&lt; &#39;\n&#39;; // Prints the address of foo
</span><span class="athl-line" data-athl-line="238">// Doesn&#39;t reassign &quot;fooRef&quot;. This is the same as &quot;foo = bar&quot;, and
</span><span class="athl-line" data-athl-line="239">//   foo == &quot;I am bar&quot;
</span><span class="athl-line" data-athl-line="240">// after this line.
</span><span class="athl-line" data-athl-line="241">fooRef = bar;
</span><span class="athl-line" data-athl-line="242">std::cout &lt;&lt; &amp;fooRef &lt;&lt; &#39;\n&#39;; // Still prints the address of foo
</span><span class="athl-line" data-athl-line="243">std::cout &lt;&lt; fooRef &lt;&lt; &#39;\n&#39;;  // Prints &quot;I am bar&quot;
</span><span class="athl-line" data-athl-line="244">
</span><span class="athl-line" data-athl-line="245">// The address of fooRef remains the same, i.e. it is still referring to foo.
</span><span class="athl-line" data-athl-line="246">
</span><span class="athl-line" data-athl-line="247">
</span><span class="athl-line" data-athl-line="248">const std::string&amp; barRef = bar; // Create a const reference to bar.
</span><span class="athl-line" data-athl-line="249">// Like C, const values (and pointers and references) cannot be modified.
</span><span class="athl-line" data-athl-line="250">barRef += &quot;. Hi!&quot;; // Error, const references cannot be modified.
</span><span class="athl-line" data-athl-line="251">
</span><span class="athl-line" data-athl-line="252">// Sidetrack: Before we talk more about references, we must introduce a concept
</span><span class="athl-line" data-athl-line="253">// called a temporary object. Suppose we have the following code:
</span><span class="athl-line" data-athl-line="254">std::string tempObjectFun() { ... }
</span><span class="athl-line" data-athl-line="255">std::string retVal = tempObjectFun();
</span><span class="athl-line" data-athl-line="256">
</span><span class="athl-line" data-athl-line="257">// What happens in the second line is actually:
</span><span class="athl-line" data-athl-line="258">//   - a string object is returned from tempObjectFun
</span><span class="athl-line" data-athl-line="259">//   - a new string is constructed with the returned object as argument to the
</span><span class="athl-line" data-athl-line="260">//     constructor
</span><span class="athl-line" data-athl-line="261">//   - the returned object is destroyed
</span><span class="athl-line" data-athl-line="262">// The returned object is called a temporary object. Temporary objects are
</span><span class="athl-line" data-athl-line="263">// created whenever a function returns an object, and they are destroyed at the
</span><span class="athl-line" data-athl-line="264">// end of the evaluation of the enclosing expression (Well, this is what the
</span><span class="athl-line" data-athl-line="265">// standard says, but compilers are allowed to change this behavior. Look up
</span><span class="athl-line" data-athl-line="266">// &quot;return value optimization&quot; if you&#39;re into these kinds of details). So in
</span><span class="athl-line" data-athl-line="267">// this code:
</span><span class="athl-line" data-athl-line="268">foo(bar(tempObjectFun()))
</span><span class="athl-line" data-athl-line="269">
</span><span class="athl-line" data-athl-line="270">// assuming foo and bar exist, the object returned from tempObjectFun is
</span><span class="athl-line" data-athl-line="271">// passed to bar, and it is destroyed before foo is called.
</span><span class="athl-line" data-athl-line="272">
</span><span class="athl-line" data-athl-line="273">// Now back to references. The exception to the &quot;at the end of the enclosing
</span><span class="athl-line" data-athl-line="274">// expression&quot; rule is if a temporary object is bound to a const reference, in
</span><span class="athl-line" data-athl-line="275">// which case its life gets extended to the current scope:
</span><span class="athl-line" data-athl-line="276">
</span><span class="athl-line" data-athl-line="277">void constReferenceTempObjectFun() {
</span><span class="athl-line" data-athl-line="278">    // constRef gets the temporary object, and it is valid until the end of this
</span><span class="athl-line" data-athl-line="279">    // function.
</span><span class="athl-line" data-athl-line="280">    const std::string&amp; constRef = tempObjectFun();
</span><span class="athl-line" data-athl-line="281">    ...
</span><span class="athl-line" data-athl-line="282">}
</span><span class="athl-line" data-athl-line="283">
</span><span class="athl-line" data-athl-line="284">// Another kind of reference introduced in C++11 is specifically for temporary
</span><span class="athl-line" data-athl-line="285">// objects. You cannot have a variable of its type, but it takes precedence in
</span><span class="athl-line" data-athl-line="286">// overload resolution:
</span><span class="athl-line" data-athl-line="287">
</span><span class="athl-line" data-athl-line="288">void someFun(std::string&amp; s) { ... }  // Regular reference
</span><span class="athl-line" data-athl-line="289">void someFun(std::string&amp;&amp; s) { ... }  // Reference to temporary object
</span><span class="athl-line" data-athl-line="290">
</span><span class="athl-line" data-athl-line="291">std::string foo;
</span><span class="athl-line" data-athl-line="292">someFun(foo);  // Calls the version with regular reference
</span><span class="athl-line" data-athl-line="293">someFun(tempObjectFun());  // Calls the version with temporary reference
</span><span class="athl-line" data-athl-line="294">
</span><span class="athl-line" data-athl-line="295">// For example, you will see these two versions of constructors for
</span><span class="athl-line" data-athl-line="296">// std::basic_string:
</span><span class="athl-line" data-athl-line="297">std::<span style="color: #8caaee;">basic_string</span>(const basic_string&amp; other);
</span><span class="athl-line" data-athl-line="298">std::<span style="color: #8caaee;">basic_string</span>(basic_string&amp;&amp; other);
</span><span class="athl-line" data-athl-line="299">
</span><span class="athl-line" data-athl-line="300">// Idea being if we are constructing a new string from a temporary object (which
</span><span class="athl-line" data-athl-line="301">// is going to be destroyed soon anyway), we can have a more efficient
</span><span class="athl-line" data-athl-line="302">// constructor that &quot;salvages&quot; parts of that temporary string. You will see this
</span><span class="athl-line" data-athl-line="303">// concept referred to as &quot;move semantics&quot;.
</span><span class="athl-line" data-athl-line="304">
</span><span class="athl-line" data-athl-line="305">/////////////////////
</span><span class="athl-line" data-athl-line="306">// Enums
</span><span class="athl-line" data-athl-line="307">/////////////////////
</span><span class="athl-line" data-athl-line="308">
</span><span class="athl-line" data-athl-line="309">// Enums are a way to assign a value to a constant most commonly used for
</span><span class="athl-line" data-athl-line="310">// easier visualization and reading of code
</span><span class="athl-line" data-athl-line="311">enum ECarTypes
</span><span class="athl-line" data-athl-line="312">{
</span><span class="athl-line" data-athl-line="313">    Sedan,
</span><span class="athl-line" data-athl-line="314">    Hatchback,
</span><span class="athl-line" data-athl-line="315">    SUV,
</span><span class="athl-line" data-athl-line="316">    Wagon
</span><span class="athl-line" data-athl-line="317">};
</span><span class="athl-line" data-athl-line="318">
</span><span class="athl-line" data-athl-line="319">ECarTypes GetPreferredCarType()
</span><span class="athl-line" data-athl-line="320">{
</span><span class="athl-line" data-athl-line="321">    return <span style="color: #e5c890;">ECarTypes</span>::Hatchback;
</span><span class="athl-line" data-athl-line="322">}
</span><span class="athl-line" data-athl-line="323">
</span><span class="athl-line" data-athl-line="324">// As of C++11 there is an easy way to assign a type to the enum which can be
</span><span class="athl-line" data-athl-line="325">// useful in serialization of data and converting enums back-and-forth between
</span><span class="athl-line" data-athl-line="326">// the desired type and their respective constants
</span><span class="athl-line" data-athl-line="327">enum ECarTypes : uint8_t
</span><span class="athl-line" data-athl-line="328">{
</span><span class="athl-line" data-athl-line="329">    Sedan, // 0
</span><span class="athl-line" data-athl-line="330">    Hatchback, // 1
</span><span class="athl-line" data-athl-line="331">    SUV = 254, // 254
</span><span class="athl-line" data-athl-line="332">    Hybrid // 255
</span><span class="athl-line" data-athl-line="333">};
</span><span class="athl-line" data-athl-line="334">
</span><span class="athl-line" data-athl-line="335">void WriteByteToFile(uint8_t InputValue)
</span><span class="athl-line" data-athl-line="336">{
</span><span class="athl-line" data-athl-line="337">    // Serialize the InputValue to a file
</span><span class="athl-line" data-athl-line="338">}
</span><span class="athl-line" data-athl-line="339">
</span><span class="athl-line" data-athl-line="340">void WritePreferredCarTypeToFile(ECarTypes InputCarType)
</span><span class="athl-line" data-athl-line="341">{
</span><span class="athl-line" data-athl-line="342">    // The enum is implicitly converted to a uint8_t due to its declared enum type
</span><span class="athl-line" data-athl-line="343">    WriteByteToFile(InputCarType);
</span><span class="athl-line" data-athl-line="344">}
</span><span class="athl-line" data-athl-line="345">
</span><span class="athl-line" data-athl-line="346">// On the other hand you may not want enums to be accidentally cast to an integer
</span><span class="athl-line" data-athl-line="347">// type or to other enums so it is instead possible to create an enum class which
</span><span class="athl-line" data-athl-line="348">// won&#39;t be implicitly converted
</span><span class="athl-line" data-athl-line="349">enum <span style="color: #ca9ee6;">class</span> ECarTypes : uint8_t
</span><span class="athl-line" data-athl-line="350">{
</span><span class="athl-line" data-athl-line="351">    Sedan, // 0
</span><span class="athl-line" data-athl-line="352">    Hatchback, // 1
</span><span class="athl-line" data-athl-line="353">    SUV = 254, // 254
</span><span class="athl-line" data-athl-line="354">    Hybrid // 255
</span><span class="athl-line" data-athl-line="355">};
</span><span class="athl-line" data-athl-line="356">
</span><span class="athl-line" data-athl-line="357">void WriteByteToFile(uint8_t InputValue)
</span><span class="athl-line" data-athl-line="358">{
</span><span class="athl-line" data-athl-line="359">    // Serialize the InputValue to a file
</span><span class="athl-line" data-athl-line="360">}
</span><span class="athl-line" data-athl-line="361">
</span><span class="athl-line" data-athl-line="362">void WritePreferredCarTypeToFile(ECarTypes InputCarType)
</span><span class="athl-line" data-athl-line="363">{
</span><span class="athl-line" data-athl-line="364">    // Won&#39;t compile even though ECarTypes is a uint8_t due to the enum
</span><span class="athl-line" data-athl-line="365">    // being declared as an &quot;enum class&quot;!
</span><span class="athl-line" data-athl-line="366">    WriteByteToFile(InputCarType);
</span><span class="athl-line" data-athl-line="367">}
</span><span class="athl-line" data-athl-line="368">
</span><span class="athl-line" data-athl-line="369">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="370">// Classes and object-oriented programming
</span><span class="athl-line" data-athl-line="371">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="372">
</span><span class="athl-line" data-athl-line="373">// First example of classes
</span><span class="athl-line" data-athl-line="374">#include &lt;iostream&gt;
</span><span class="athl-line" data-athl-line="375">
</span><span class="athl-line" data-athl-line="376">// Declare a class.
</span><span class="athl-line" data-athl-line="377">// Classes are usually declared in header (.h or .hpp) files.
</span><span class="athl-line" data-athl-line="378"><span style="color: #ca9ee6;">class</span> Dog {
</span><span class="athl-line" data-athl-line="379">    // Member variables and functions are private by default.
</span><span class="athl-line" data-athl-line="380">    std::string name;
</span><span class="athl-line" data-athl-line="381">    int weight;
</span><span class="athl-line" data-athl-line="382">
</span><span class="athl-line" data-athl-line="383">// All members following this are public
</span><span class="athl-line" data-athl-line="384">// until &quot;private:&quot; or &quot;protected:&quot; is found.
</span><span class="athl-line" data-athl-line="385"><span style="color: #ca9ee6;">public</span>:
</span><span class="athl-line" data-athl-line="386">
</span><span class="athl-line" data-athl-line="387">    // Default constructor
</span><span class="athl-line" data-athl-line="388">    Dog();
</span><span class="athl-line" data-athl-line="389">
</span><span class="athl-line" data-athl-line="390">    // Member function declarations (implementations to follow)
</span><span class="athl-line" data-athl-line="391">    // Note that we use std::string here instead of placing
</span><span class="athl-line" data-athl-line="392">    // using namespace std;
</span><span class="athl-line" data-athl-line="393">    // above.
</span><span class="athl-line" data-athl-line="394">    // Never put a &quot;using namespace&quot; statement in a header.
</span><span class="athl-line" data-athl-line="395">    void <span style="color: #8caaee;">setName</span>(const std::string&amp; dogsName);
</span><span class="athl-line" data-athl-line="396">
</span><span class="athl-line" data-athl-line="397">    void <span style="color: #8caaee;">setWeight</span>(int dogsWeight);
</span><span class="athl-line" data-athl-line="398">
</span><span class="athl-line" data-athl-line="399">    // Functions that do not modify the state of the object
</span><span class="athl-line" data-athl-line="400">    // should be marked as const.
</span><span class="athl-line" data-athl-line="401">    // This allows you to call them if given a const reference to the object.
</span><span class="athl-line" data-athl-line="402">    // Also note the functions must be explicitly declared as _virtual_
</span><span class="athl-line" data-athl-line="403">    // in order to be overridden in derived classes.
</span><span class="athl-line" data-athl-line="404">    // Functions are not virtual by default for performance reasons.
</span><span class="athl-line" data-athl-line="405">    <span style="color: #ca9ee6;">virtual</span> void <span style="color: #8caaee;">print</span>() const;
</span><span class="athl-line" data-athl-line="406">
</span><span class="athl-line" data-athl-line="407">    // Functions can also be defined inside the class body.
</span><span class="athl-line" data-athl-line="408">    // Functions defined as such are automatically inlined.
</span><span class="athl-line" data-athl-line="409">    void <span style="color: #8caaee;">bark</span>() const { std::cout &lt;&lt; name &lt;&lt; &quot; barks!\n&quot;; }
</span><span class="athl-line" data-athl-line="410">
</span><span class="athl-line" data-athl-line="411">    // Along with constructors, C++ provides destructors.
</span><span class="athl-line" data-athl-line="412">    // These are called when an object is deleted or falls out of scope.
</span><span class="athl-line" data-athl-line="413">    // This enables powerful paradigms such as RAII
</span><span class="athl-line" data-athl-line="414">    // (see below)
</span><span class="athl-line" data-athl-line="415">    // The destructor should be virtual if a class is to be derived from;
</span><span class="athl-line" data-athl-line="416">    // if it is not virtual, then the derived class&#39; destructor will
</span><span class="athl-line" data-athl-line="417">    // not be called if the object is destroyed through a base-class reference
</span><span class="athl-line" data-athl-line="418">    // or pointer.
</span><span class="athl-line" data-athl-line="419">    <span style="color: #ca9ee6;">virtual</span> ~Dog();
</span><span class="athl-line" data-athl-line="420">
</span><span class="athl-line" data-athl-line="421">}; // A semicolon must follow the class definition.
</span><span class="athl-line" data-athl-line="422">
</span><span class="athl-line" data-athl-line="423">// Class member functions are usually implemented in .cpp files.
</span><span class="athl-line" data-athl-line="424"><span style="color: #e5c890;">Dog</span>::<span style="color: #8caaee;">Dog</span>()
</span><span class="athl-line" data-athl-line="425">{
</span><span class="athl-line" data-athl-line="426">    std::cout &lt;&lt; &quot;A dog has been constructed\n&quot;;
</span><span class="athl-line" data-athl-line="427">}
</span><span class="athl-line" data-athl-line="428">
</span><span class="athl-line" data-athl-line="429">// Objects (such as strings) should be passed by reference
</span><span class="athl-line" data-athl-line="430">// if you are modifying them or const reference if you are not.
</span><span class="athl-line" data-athl-line="431">void <span style="color: #e5c890;">Dog</span>::<span style="color: #8caaee;">setName</span>(const std::string&amp; dogsName)
</span><span class="athl-line" data-athl-line="432">{
</span><span class="athl-line" data-athl-line="433">    name = dogsName;
</span><span class="athl-line" data-athl-line="434">}
</span><span class="athl-line" data-athl-line="435">
</span><span class="athl-line" data-athl-line="436">void <span style="color: #e5c890;">Dog</span>::<span style="color: #8caaee;">setWeight</span>(int dogsWeight)
</span><span class="athl-line" data-athl-line="437">{
</span><span class="athl-line" data-athl-line="438">    weight = dogsWeight;
</span><span class="athl-line" data-athl-line="439">}
</span><span class="athl-line" data-athl-line="440">
</span><span class="athl-line" data-athl-line="441">// Notice that &quot;virtual&quot; is only needed in the declaration, not the definition.
</span><span class="athl-line" data-athl-line="442">void <span style="color: #e5c890;">Dog</span>::<span style="color: #8caaee;">print</span>() const
</span><span class="athl-line" data-athl-line="443">{
</span><span class="athl-line" data-athl-line="444">    std::cout &lt;&lt; &quot;Dog is &quot; &lt;&lt; name &lt;&lt; &quot; and weighs &quot; &lt;&lt; weight &lt;&lt; &quot;kg\n&quot;;
</span><span class="athl-line" data-athl-line="445">}
</span><span class="athl-line" data-athl-line="446">
</span><span class="athl-line" data-athl-line="447"><span style="color: #e5c890;">Dog</span>::~Dog()
</span><span class="athl-line" data-athl-line="448">{
</span><span class="athl-line" data-athl-line="449">    std::cout &lt;&lt; &quot;Goodbye &quot; &lt;&lt; name &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="450">}
</span><span class="athl-line" data-athl-line="451">
</span><span class="athl-line" data-athl-line="452">int main() {
</span><span class="athl-line" data-athl-line="453">    Dog myDog; // prints &quot;A dog has been constructed&quot;
</span><span class="athl-line" data-athl-line="454">    myDog.setName(&quot;Barkley&quot;);
</span><span class="athl-line" data-athl-line="455">    myDog.setWeight(10);
</span><span class="athl-line" data-athl-line="456">    myDog.print(); // prints &quot;Dog is Barkley and weighs 10 kg&quot;
</span><span class="athl-line" data-athl-line="457">    return 0;
</span><span class="athl-line" data-athl-line="458">} // prints &quot;Goodbye Barkley&quot;
</span><span class="athl-line" data-athl-line="459">
</span><span class="athl-line" data-athl-line="460">// Inheritance:
</span><span class="athl-line" data-athl-line="461">
</span><span class="athl-line" data-athl-line="462">// This class inherits everything public and protected from the Dog class
</span><span class="athl-line" data-athl-line="463">// as well as private but may not directly access private members/methods
</span><span class="athl-line" data-athl-line="464">// without a public or protected method for doing so
</span><span class="athl-line" data-athl-line="465"><span style="color: #ca9ee6;">class</span> OwnedDog : <span style="color: #ca9ee6;">public</span> Dog {
</span><span class="athl-line" data-athl-line="466">
</span><span class="athl-line" data-athl-line="467"><span style="color: #ca9ee6;">public</span>:
</span><span class="athl-line" data-athl-line="468">    void <span style="color: #8caaee;">setOwner</span>(const std::string&amp; dogsOwner);
</span><span class="athl-line" data-athl-line="469">
</span><span class="athl-line" data-athl-line="470">    // Override the behavior of the print function for all OwnedDogs. See
</span><span class="athl-line" data-athl-line="471">    // https://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping
</span><span class="athl-line" data-athl-line="472">    // for a more general introduction if you are unfamiliar with
</span><span class="athl-line" data-athl-line="473">    // subtype polymorphism.
</span><span class="athl-line" data-athl-line="474">    // The override keyword is optional but makes sure you are actually
</span><span class="athl-line" data-athl-line="475">    // overriding the method in a base class.
</span><span class="athl-line" data-athl-line="476">    void <span style="color: #8caaee;">print</span>() const <span style="color: #ca9ee6;">override</span>;
</span><span class="athl-line" data-athl-line="477">
</span><span class="athl-line" data-athl-line="478"><span style="color: #ca9ee6;">private</span>:
</span><span class="athl-line" data-athl-line="479">    std::string owner;
</span><span class="athl-line" data-athl-line="480">};
</span><span class="athl-line" data-athl-line="481">
</span><span class="athl-line" data-athl-line="482">// Meanwhile, in the corresponding .cpp file:
</span><span class="athl-line" data-athl-line="483">
</span><span class="athl-line" data-athl-line="484">void <span style="color: #e5c890;">OwnedDog</span>::<span style="color: #8caaee;">setOwner</span>(const std::string&amp; dogsOwner)
</span><span class="athl-line" data-athl-line="485">{
</span><span class="athl-line" data-athl-line="486">    owner = dogsOwner;
</span><span class="athl-line" data-athl-line="487">}
</span><span class="athl-line" data-athl-line="488">
</span><span class="athl-line" data-athl-line="489">void <span style="color: #e5c890;">OwnedDog</span>::<span style="color: #8caaee;">print</span>() const
</span><span class="athl-line" data-athl-line="490">{
</span><span class="athl-line" data-athl-line="491">    <span style="color: #e5c890;">Dog</span>::<span style="color: #8caaee;">print</span>(); // Call the print function in the base Dog class
</span><span class="athl-line" data-athl-line="492">    std::cout &lt;&lt; &quot;Dog is owned by &quot; &lt;&lt; owner &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="493">    // Prints &quot;Dog is &lt;name&gt; and weights &lt;weight&gt;&quot;
</span><span class="athl-line" data-athl-line="494">    //        &quot;Dog is owned by &lt;owner&gt;&quot;
</span><span class="athl-line" data-athl-line="495">}
</span><span class="athl-line" data-athl-line="496">
</span><span class="athl-line" data-athl-line="497">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="498">// Initialization and Operator Overloading
</span><span class="athl-line" data-athl-line="499">//////////////////////////////////////////
</span><span class="athl-line" data-athl-line="500">
</span><span class="athl-line" data-athl-line="501">// In C++ you can overload the behavior of operators such as +, -, *, /, etc.
</span><span class="athl-line" data-athl-line="502">// This is done by defining a function which is called
</span><span class="athl-line" data-athl-line="503">// whenever the operator is used.
</span><span class="athl-line" data-athl-line="504">
</span><span class="athl-line" data-athl-line="505">#include &lt;iostream&gt;
</span><span class="athl-line" data-athl-line="506"><span style="color: #ca9ee6;">using</span> <span style="color: #ca9ee6;">namespace</span> std;
</span><span class="athl-line" data-athl-line="507">
</span><span class="athl-line" data-athl-line="508"><span style="color: #ca9ee6;">class</span> Point {
</span><span class="athl-line" data-athl-line="509"><span style="color: #ca9ee6;">public</span>:
</span><span class="athl-line" data-athl-line="510">    // Member variables can be given default values in this manner.
</span><span class="athl-line" data-athl-line="511">    double x = 0;
</span><span class="athl-line" data-athl-line="512">    double y = 0;
</span><span class="athl-line" data-athl-line="513">
</span><span class="athl-line" data-athl-line="514">    // Define a default constructor which does nothing
</span><span class="athl-line" data-athl-line="515">    // but initialize the Point to the default value (0, 0)
</span><span class="athl-line" data-athl-line="516">    Point() { };
</span><span class="athl-line" data-athl-line="517">
</span><span class="athl-line" data-athl-line="518">    // The following syntax is known as an initialization list
</span><span class="athl-line" data-athl-line="519">    // and is the proper way to initialize class member values
</span><span class="athl-line" data-athl-line="520">    Point (double a, double b) :
</span><span class="athl-line" data-athl-line="521">        x(a),
</span><span class="athl-line" data-athl-line="522">        y(b)
</span><span class="athl-line" data-athl-line="523">    { /* Do nothing except initialize the values */ }
</span><span class="athl-line" data-athl-line="524">
</span><span class="athl-line" data-athl-line="525">    // Overload the + operator.
</span><span class="athl-line" data-athl-line="526">    Point operator+(const Point&amp; rhs) const;
</span><span class="athl-line" data-athl-line="527">
</span><span class="athl-line" data-athl-line="528">    // Overload the += operator
</span><span class="athl-line" data-athl-line="529">    Point&amp; operator+=(const Point&amp; rhs);
</span><span class="athl-line" data-athl-line="530">
</span><span class="athl-line" data-athl-line="531">    // It would also make sense to add the - and -= operators,
</span><span class="athl-line" data-athl-line="532">    // but we will skip those for brevity.
</span><span class="athl-line" data-athl-line="533">};
</span><span class="athl-line" data-athl-line="534">
</span><span class="athl-line" data-athl-line="535">Point <span style="color: #e5c890;">Point</span>::operator+(const Point&amp; rhs) const
</span><span class="athl-line" data-athl-line="536">{
</span><span class="athl-line" data-athl-line="537">    // Create a new point that is the sum of this one and rhs.
</span><span class="athl-line" data-athl-line="538">    return Point(x + rhs.x, y + rhs.y);
</span><span class="athl-line" data-athl-line="539">}
</span><span class="athl-line" data-athl-line="540">
</span><span class="athl-line" data-athl-line="541">// It&#39;s good practice to return a reference to the leftmost variable of
</span><span class="athl-line" data-athl-line="542">// an assignment. `(a += b) == c` will work this way.
</span><span class="athl-line" data-athl-line="543">Point&amp; <span style="color: #e5c890;">Point</span>::operator+=(const Point&amp; rhs)
</span><span class="athl-line" data-athl-line="544">{
</span><span class="athl-line" data-athl-line="545">    x += rhs.x;
</span><span class="athl-line" data-athl-line="546">    y += rhs.y;
</span><span class="athl-line" data-athl-line="547">
</span><span class="athl-line" data-athl-line="548">    // `this` is a pointer to the object, on which a method is called.
</span><span class="athl-line" data-athl-line="549">    return *<span style="color: #e78284;">this</span>;
</span><span class="athl-line" data-athl-line="550">}
</span><span class="athl-line" data-athl-line="551">
</span><span class="athl-line" data-athl-line="552">int main () {
</span><span class="athl-line" data-athl-line="553">    Point up (0,1);
</span><span class="athl-line" data-athl-line="554">    Point right (1,0);
</span><span class="athl-line" data-athl-line="555">    // This calls the Point + operator
</span><span class="athl-line" data-athl-line="556">    // Point up calls the + (function) with right as its parameter
</span><span class="athl-line" data-athl-line="557">    Point result = up + right;
</span><span class="athl-line" data-athl-line="558">    // Prints &quot;Result is upright (1,1)&quot;
</span><span class="athl-line" data-athl-line="559">    std::cout &lt;&lt; &quot;Result is upright (&quot; &lt;&lt; result.x &lt;&lt; &#39;,&#39; &lt;&lt; result.y &lt;&lt; &quot;)\n&quot;;
</span><span class="athl-line" data-athl-line="560">    return 0;
</span><span class="athl-line" data-athl-line="561">}
</span><span class="athl-line" data-athl-line="562">
</span><span class="athl-line" data-athl-line="563">/////////////////////
</span><span class="athl-line" data-athl-line="564">// Templates
</span><span class="athl-line" data-athl-line="565">/////////////////////
</span><span class="athl-line" data-athl-line="566">
</span><span class="athl-line" data-athl-line="567">// Templates in C++ are mostly used for generic programming, though they are
</span><span class="athl-line" data-athl-line="568">// much more powerful than generic constructs in other languages. They also
</span><span class="athl-line" data-athl-line="569">// support explicit and partial specialization and functional-style type
</span><span class="athl-line" data-athl-line="570">// classes; in fact, they are a Turing-complete functional language embedded
</span><span class="athl-line" data-athl-line="571">// in C++!
</span><span class="athl-line" data-athl-line="572">
</span><span class="athl-line" data-athl-line="573">// We start with the kind of generic programming you might be familiar with. To
</span><span class="athl-line" data-athl-line="574">// define a class or function that takes a type parameter:
</span><span class="athl-line" data-athl-line="575"><span style="color: #ca9ee6;">template</span>&lt;<span style="color: #ca9ee6;">class</span> T&gt;
</span><span class="athl-line" data-athl-line="576"><span style="color: #ca9ee6;">class</span> Box {
</span><span class="athl-line" data-athl-line="577"><span style="color: #ca9ee6;">public</span>:
</span><span class="athl-line" data-athl-line="578">    // In this class, T can be used as any other type.
</span><span class="athl-line" data-athl-line="579">    void <span style="color: #8caaee;">insert</span>(const T&amp;) { ... }
</span><span class="athl-line" data-athl-line="580">};
</span><span class="athl-line" data-athl-line="581">
</span><span class="athl-line" data-athl-line="582">// During compilation, the compiler actually generates copies of each template
</span><span class="athl-line" data-athl-line="583">// with parameters substituted, so the full definition of the class must be
</span><span class="athl-line" data-athl-line="584">// present at each invocation. This is why you will see template classes defined
</span><span class="athl-line" data-athl-line="585">// entirely in header files.
</span><span class="athl-line" data-athl-line="586">
</span><span class="athl-line" data-athl-line="587">// To instantiate a template class on the stack:
</span><span class="athl-line" data-athl-line="588">Box&lt;int&gt; intBox;
</span><span class="athl-line" data-athl-line="589">
</span><span class="athl-line" data-athl-line="590">// and you can use it as you would expect:
</span><span class="athl-line" data-athl-line="591">intBox.insert(123);
</span><span class="athl-line" data-athl-line="592">
</span><span class="athl-line" data-athl-line="593">// You can, of course, nest templates:
</span><span class="athl-line" data-athl-line="594">Box&lt;Box&lt;int&gt; &gt; boxOfBox;
</span><span class="athl-line" data-athl-line="595">boxOfBox.insert(intBox);
</span><span class="athl-line" data-athl-line="596">
</span><span class="athl-line" data-athl-line="597">// Until C++11, you had to place a space between the two &#39;&gt;&#39;s, otherwise &#39;&gt;&gt;&#39;
</span><span class="athl-line" data-athl-line="598">// would be parsed as the right shift operator.
</span><span class="athl-line" data-athl-line="599">
</span><span class="athl-line" data-athl-line="600">// You will sometimes see
</span><span class="athl-line" data-athl-line="601">//   template&lt;typename T&gt;
</span><span class="athl-line" data-athl-line="602">// instead. The &#39;class&#39; keyword and &#39;typename&#39; keywords are _mostly_
</span><span class="athl-line" data-athl-line="603">// interchangeable in this case. For the full explanation, see
</span><span class="athl-line" data-athl-line="604">//   https://en.wikipedia.org/wiki/Typename
</span><span class="athl-line" data-athl-line="605">// (yes, that keyword has its own Wikipedia page).
</span><span class="athl-line" data-athl-line="606">
</span><span class="athl-line" data-athl-line="607">// Similarly, a template function:
</span><span class="athl-line" data-athl-line="608"><span style="color: #ca9ee6;">template</span>&lt;<span style="color: #ca9ee6;">class</span> T&gt;
</span><span class="athl-line" data-athl-line="609">void barkThreeTimes(const T&amp; input)
</span><span class="athl-line" data-athl-line="610">{
</span><span class="athl-line" data-athl-line="611">    input.bark();
</span><span class="athl-line" data-athl-line="612">    input.bark();
</span><span class="athl-line" data-athl-line="613">    input.bark();
</span><span class="athl-line" data-athl-line="614">}
</span><span class="athl-line" data-athl-line="615">
</span><span class="athl-line" data-athl-line="616">// Notice that nothing is specified about the type parameters here. The compiler
</span><span class="athl-line" data-athl-line="617">// will generate and then type-check every invocation of the template, so the
</span><span class="athl-line" data-athl-line="618">// above function works with any type &#39;T&#39; that has a const &#39;bark&#39; method!
</span><span class="athl-line" data-athl-line="619">
</span><span class="athl-line" data-athl-line="620">Dog fluffy;
</span><span class="athl-line" data-athl-line="621">fluffy.setName(&quot;Fluffy&quot;)
</span><span class="athl-line" data-athl-line="622">barkThreeTimes(fluffy); // Prints &quot;Fluffy barks&quot; three times.
</span><span class="athl-line" data-athl-line="623">
</span><span class="athl-line" data-athl-line="624">// Template parameters don&#39;t have to be classes:
</span><span class="athl-line" data-athl-line="625"><span style="color: #ca9ee6;">template</span>&lt;int Y&gt;
</span><span class="athl-line" data-athl-line="626">void printMessage() {
</span><span class="athl-line" data-athl-line="627">    std::cout &lt;&lt; &quot;Learn C++ in &quot; &lt;&lt; Y &lt;&lt; &quot; minutes!\n&quot;;
</span><span class="athl-line" data-athl-line="628">}
</span><span class="athl-line" data-athl-line="629">
</span><span class="athl-line" data-athl-line="630">// And you can explicitly specialize templates for more efficient code. Of
</span><span class="athl-line" data-athl-line="631">// course, most real-world uses of specialization are not as trivial as this.
</span><span class="athl-line" data-athl-line="632">// Note that you still need to declare the function (or class) as a template
</span><span class="athl-line" data-athl-line="633">// even if you explicitly specified all parameters.
</span><span class="athl-line" data-athl-line="634"><span style="color: #ca9ee6;">template</span>&lt;&gt;
</span><span class="athl-line" data-athl-line="635">void <span style="color: #8caaee;">printMessage</span>&lt;10&gt;() {
</span><span class="athl-line" data-athl-line="636">    std::cout &lt;&lt; &quot;Learn C++ faster in only 10 minutes!\n&quot;;
</span><span class="athl-line" data-athl-line="637">}
</span><span class="athl-line" data-athl-line="638">
</span><span class="athl-line" data-athl-line="639"><span style="color: #8caaee;">printMessage</span>&lt;20&gt;();  // Prints &quot;Learn C++ in 20 minutes!&quot;
</span><span class="athl-line" data-athl-line="640"><span style="color: #8caaee;">printMessage</span>&lt;10&gt;();  // Prints &quot;Learn C++ faster in only 10 minutes!&quot;
</span><span class="athl-line" data-athl-line="641">
</span><span class="athl-line" data-athl-line="642">
</span><span class="athl-line" data-athl-line="643">/////////////////////
</span><span class="athl-line" data-athl-line="644">// Exception Handling
</span><span class="athl-line" data-athl-line="645">/////////////////////
</span><span class="athl-line" data-athl-line="646">
</span><span class="athl-line" data-athl-line="647">// The standard library provides a few exception types
</span><span class="athl-line" data-athl-line="648">// (see https://en.cppreference.com/w/cpp/error/exception)
</span><span class="athl-line" data-athl-line="649">// but any type can be thrown as an exception
</span><span class="athl-line" data-athl-line="650">#include &lt;exception&gt;
</span><span class="athl-line" data-athl-line="651">#include &lt;stdexcept&gt;
</span><span class="athl-line" data-athl-line="652">
</span><span class="athl-line" data-athl-line="653">// All exceptions thrown inside the _try_ block can be caught by subsequent
</span><span class="athl-line" data-athl-line="654">// _catch_ handlers.
</span><span class="athl-line" data-athl-line="655"><span style="color: #ca9ee6;">try</span> {
</span><span class="athl-line" data-athl-line="656">    // Do not allocate exceptions on the heap using _new_.
</span><span class="athl-line" data-athl-line="657">    <span style="color: #ca9ee6;">throw</span> std::<span style="color: #8caaee;">runtime_error</span>(&quot;A problem occurred&quot;);
</span><span class="athl-line" data-athl-line="658">}
</span><span class="athl-line" data-athl-line="659">
</span><span class="athl-line" data-athl-line="660">// Catch exceptions by const reference if they are objects
</span><span class="athl-line" data-athl-line="661"><span style="color: #ca9ee6;">catch</span> (const std::exception&amp; ex)
</span><span class="athl-line" data-athl-line="662">{
</span><span class="athl-line" data-athl-line="663">    std::cout &lt;&lt; ex.what();
</span><span class="athl-line" data-athl-line="664">}
</span><span class="athl-line" data-athl-line="665">
</span><span class="athl-line" data-athl-line="666">// Catches any exception not caught by previous _catch_ blocks
</span><span class="athl-line" data-athl-line="667"><span style="color: #ca9ee6;">catch</span> (...)
</span><span class="athl-line" data-athl-line="668">{
</span><span class="athl-line" data-athl-line="669">    std::cout &lt;&lt; &quot;Unknown exception caught&quot;;
</span><span class="athl-line" data-athl-line="670">    <span style="color: #ca9ee6;">throw</span>; // Re-throws the exception
</span><span class="athl-line" data-athl-line="671">}
</span><span class="athl-line" data-athl-line="672">
</span><span class="athl-line" data-athl-line="673">///////
</span><span class="athl-line" data-athl-line="674">// RAII
</span><span class="athl-line" data-athl-line="675">///////
</span><span class="athl-line" data-athl-line="676">
</span><span class="athl-line" data-athl-line="677">// RAII stands for &quot;Resource Acquisition Is Initialization&quot;.
</span><span class="athl-line" data-athl-line="678">// It is often considered the most powerful paradigm in C++
</span><span class="athl-line" data-athl-line="679">// and is the simple concept that a constructor for an object
</span><span class="athl-line" data-athl-line="680">// acquires that object&#39;s resources and the destructor releases them.
</span><span class="athl-line" data-athl-line="681">
</span><span class="athl-line" data-athl-line="682">// To understand how this is useful,
</span><span class="athl-line" data-athl-line="683">// consider a function that uses a C file handle:
</span><span class="athl-line" data-athl-line="684">void doSomethingWithAFile(const char* filename)
</span><span class="athl-line" data-athl-line="685">{
</span><span class="athl-line" data-athl-line="686">    // To begin with, assume nothing can fail.
</span><span class="athl-line" data-athl-line="687">
</span><span class="athl-line" data-athl-line="688">    FILE* fh = fopen(filename, &quot;r&quot;); // Open the file in read mode.
</span><span class="athl-line" data-athl-line="689">    if (fh == NULL) {
</span><span class="athl-line" data-athl-line="690">        // Handle possible error
</span><span class="athl-line" data-athl-line="691">    }
</span><span class="athl-line" data-athl-line="692">
</span><span class="athl-line" data-athl-line="693">    doSomethingWithTheFile(fh);
</span><span class="athl-line" data-athl-line="694">    doSomethingElseWithIt(fh);
</span><span class="athl-line" data-athl-line="695">
</span><span class="athl-line" data-athl-line="696">    fclose(fh); // Close the file handle.
</span><span class="athl-line" data-athl-line="697">}
</span><span class="athl-line" data-athl-line="698">
</span><span class="athl-line" data-athl-line="699">// Unfortunately, things are quickly complicated by error handling.
</span><span class="athl-line" data-athl-line="700">// Suppose fopen can fail, and that doSomethingWithTheFile and
</span><span class="athl-line" data-athl-line="701">// doSomethingElseWithIt return error codes if they fail.
</span><span class="athl-line" data-athl-line="702">//  (Exceptions are the preferred way of handling failure,
</span><span class="athl-line" data-athl-line="703">//   but some programmers, especially those with a C background,
</span><span class="athl-line" data-athl-line="704">//   disagree on the utility of exceptions).
</span><span class="athl-line" data-athl-line="705">// We now have to check each call for failure and close the file handle
</span><span class="athl-line" data-athl-line="706">// if a problem occurred.
</span><span class="athl-line" data-athl-line="707">bool doSomethingWithAFile(const char* filename)
</span><span class="athl-line" data-athl-line="708">{
</span><span class="athl-line" data-athl-line="709">    FILE* fh = fopen(filename, &quot;r&quot;); // Open the file in read mode
</span><span class="athl-line" data-athl-line="710">    if (fh == <span style="color: #ef9f76;">nullptr</span>) // The returned pointer is null on failure.
</span><span class="athl-line" data-athl-line="711">        return false; // Report that failure to the caller.
</span><span class="athl-line" data-athl-line="712">
</span><span class="athl-line" data-athl-line="713">    // Assume each function returns false if it failed
</span><span class="athl-line" data-athl-line="714">    if (!doSomethingWithTheFile(fh)) {
</span><span class="athl-line" data-athl-line="715">        fclose(fh); // Close the file handle so it doesn&#39;t leak.
</span><span class="athl-line" data-athl-line="716">        return false; // Propagate the error.
</span><span class="athl-line" data-athl-line="717">    }
</span><span class="athl-line" data-athl-line="718">    if (!doSomethingElseWithIt(fh)) {
</span><span class="athl-line" data-athl-line="719">        fclose(fh); // Close the file handle so it doesn&#39;t leak.
</span><span class="athl-line" data-athl-line="720">        return false; // Propagate the error.
</span><span class="athl-line" data-athl-line="721">    }
</span><span class="athl-line" data-athl-line="722">
</span><span class="athl-line" data-athl-line="723">    fclose(fh); // Close the file handle so it doesn&#39;t leak.
</span><span class="athl-line" data-athl-line="724">    return true; // Indicate success
</span><span class="athl-line" data-athl-line="725">}
</span><span class="athl-line" data-athl-line="726">
</span><span class="athl-line" data-athl-line="727">// C programmers often clean this up a little bit using goto:
</span><span class="athl-line" data-athl-line="728">bool doSomethingWithAFile(const char* filename)
</span><span class="athl-line" data-athl-line="729">{
</span><span class="athl-line" data-athl-line="730">    FILE* fh = fopen(filename, &quot;r&quot;);
</span><span class="athl-line" data-athl-line="731">    if (fh == <span style="color: #ef9f76;">nullptr</span>)
</span><span class="athl-line" data-athl-line="732">        return false;
</span><span class="athl-line" data-athl-line="733">
</span><span class="athl-line" data-athl-line="734">    if (!doSomethingWithTheFile(fh))
</span><span class="athl-line" data-athl-line="735">        goto failure;
</span><span class="athl-line" data-athl-line="736">
</span><span class="athl-line" data-athl-line="737">    if (!doSomethingElseWithIt(fh))
</span><span class="athl-line" data-athl-line="738">        goto failure;
</span><span class="athl-line" data-athl-line="739">
</span><span class="athl-line" data-athl-line="740">    fclose(fh); // Close the file
</span><span class="athl-line" data-athl-line="741">    return true; // Indicate success
</span><span class="athl-line" data-athl-line="742">
</span><span class="athl-line" data-athl-line="743">failure:
</span><span class="athl-line" data-athl-line="744">    fclose(fh);
</span><span class="athl-line" data-athl-line="745">    return false; // Propagate the error
</span><span class="athl-line" data-athl-line="746">}
</span><span class="athl-line" data-athl-line="747">
</span><span class="athl-line" data-athl-line="748">// If the functions indicate errors using exceptions,
</span><span class="athl-line" data-athl-line="749">// things are a little cleaner, but still sub-optimal.
</span><span class="athl-line" data-athl-line="750">void doSomethingWithAFile(const char* filename)
</span><span class="athl-line" data-athl-line="751">{
</span><span class="athl-line" data-athl-line="752">    FILE* fh = fopen(filename, &quot;r&quot;); // Open the file in shared_ptrread mode
</span><span class="athl-line" data-athl-line="753">    if (fh == <span style="color: #ef9f76;">nullptr</span>)
</span><span class="athl-line" data-athl-line="754">        <span style="color: #ca9ee6;">throw</span> std::<span style="color: #8caaee;">runtime_error</span>(&quot;Could not open the file.&quot;);
</span><span class="athl-line" data-athl-line="755">
</span><span class="athl-line" data-athl-line="756">    <span style="color: #ca9ee6;">try</span> {
</span><span class="athl-line" data-athl-line="757">        doSomethingWithTheFile(fh);
</span><span class="athl-line" data-athl-line="758">        doSomethingElseWithIt(fh);
</span><span class="athl-line" data-athl-line="759">    }
</span><span class="athl-line" data-athl-line="760">    <span style="color: #ca9ee6;">catch</span> (...) {
</span><span class="athl-line" data-athl-line="761">        fclose(fh); // Be sure to close the file if an error occurs.
</span><span class="athl-line" data-athl-line="762">        <span style="color: #ca9ee6;">throw</span>; // Then re-throw the exception.
</span><span class="athl-line" data-athl-line="763">    }
</span><span class="athl-line" data-athl-line="764">
</span><span class="athl-line" data-athl-line="765">    fclose(fh); // Close the file
</span><span class="athl-line" data-athl-line="766">    // Everything succeeded
</span><span class="athl-line" data-athl-line="767">}
</span><span class="athl-line" data-athl-line="768">
</span><span class="athl-line" data-athl-line="769">// Compare this to the use of C++&#39;s file stream class (fstream)
</span><span class="athl-line" data-athl-line="770">// fstream uses its destructor to close the file.
</span><span class="athl-line" data-athl-line="771">// Recall from above that destructors are automatically called
</span><span class="athl-line" data-athl-line="772">// whenever an object falls out of scope.
</span><span class="athl-line" data-athl-line="773">void doSomethingWithAFile(const std::string&amp; filename)
</span><span class="athl-line" data-athl-line="774">{
</span><span class="athl-line" data-athl-line="775">    // ifstream is short for input file stream
</span><span class="athl-line" data-athl-line="776">    std::ifstream fh(filename); // Open the file
</span><span class="athl-line" data-athl-line="777">
</span><span class="athl-line" data-athl-line="778">    // Do things with the file
</span><span class="athl-line" data-athl-line="779">    doSomethingWithTheFile(fh);
</span><span class="athl-line" data-athl-line="780">    doSomethingElseWithIt(fh);
</span><span class="athl-line" data-athl-line="781">
</span><span class="athl-line" data-athl-line="782">} // The file is automatically closed here by the destructor
</span><span class="athl-line" data-athl-line="783">
</span><span class="athl-line" data-athl-line="784">// This has _massive_ advantages:
</span><span class="athl-line" data-athl-line="785">// 1. No matter what happens,
</span><span class="athl-line" data-athl-line="786">//    the resource (in this case the file handle) will be cleaned up.
</span><span class="athl-line" data-athl-line="787">//    Once you write the destructor correctly,
</span><span class="athl-line" data-athl-line="788">//    It is _impossible_ to forget to close the handle and leak the resource.
</span><span class="athl-line" data-athl-line="789">// 2. Note that the code is much cleaner.
</span><span class="athl-line" data-athl-line="790">//    The destructor handles closing the file behind the scenes
</span><span class="athl-line" data-athl-line="791">//    without you having to worry about it.
</span><span class="athl-line" data-athl-line="792">// 3. The code is exception safe.
</span><span class="athl-line" data-athl-line="793">//    An exception can be thrown anywhere in the function and cleanup
</span><span class="athl-line" data-athl-line="794">//    will still occur.
</span><span class="athl-line" data-athl-line="795">
</span><span class="athl-line" data-athl-line="796">// All idiomatic C++ code uses RAII extensively for all resources.
</span><span class="athl-line" data-athl-line="797">// Additional examples include
</span><span class="athl-line" data-athl-line="798">// - Memory using unique_ptr and shared_ptr
</span><span class="athl-line" data-athl-line="799">// - Containers - the standard library linked list,
</span><span class="athl-line" data-athl-line="800">//   vector (i.e. self-resizing array), hash maps, and so on
</span><span class="athl-line" data-athl-line="801">//   all automatically destroy their contents when they fall out of scope.
</span><span class="athl-line" data-athl-line="802">// - Mutexes using lock_guard and unique_lock
</span><span class="athl-line" data-athl-line="803">
</span><span class="athl-line" data-athl-line="804">
</span><span class="athl-line" data-athl-line="805">/////////////////////
</span><span class="athl-line" data-athl-line="806">// Smart Pointer
</span><span class="athl-line" data-athl-line="807">/////////////////////
</span><span class="athl-line" data-athl-line="808">
</span><span class="athl-line" data-athl-line="809">// Generally a smart pointer is a class which wraps a &quot;raw pointer&quot; (usage of &quot;new&quot;
</span><span class="athl-line" data-athl-line="810">// respectively malloc/calloc in C). The goal is to be able to
</span><span class="athl-line" data-athl-line="811">// manage the lifetime of the object being pointed to without ever needing to explicitly delete
</span><span class="athl-line" data-athl-line="812">// the object. The term itself simply describes a set of pointers with the
</span><span class="athl-line" data-athl-line="813">// mentioned abstraction.
</span><span class="athl-line" data-athl-line="814">// Smart pointers should be preferred over raw pointers, to prevent
</span><span class="athl-line" data-athl-line="815">// risky memory leaks, which happen if you forget to delete an object.
</span><span class="athl-line" data-athl-line="816">
</span><span class="athl-line" data-athl-line="817">// Usage of a raw pointer:
</span><span class="athl-line" data-athl-line="818">Dog* ptr = <span style="color: #ca9ee6;">new</span> Dog();
</span><span class="athl-line" data-athl-line="819">ptr-&gt;bark();
</span><span class="athl-line" data-athl-line="820"><span style="color: #ca9ee6;">delete</span> ptr;
</span><span class="athl-line" data-athl-line="821">
</span><span class="athl-line" data-athl-line="822">// By using a smart pointer, you don&#39;t have to worry about the deletion
</span><span class="athl-line" data-athl-line="823">// of the object anymore.
</span><span class="athl-line" data-athl-line="824">// A smart pointer describes a policy, to count the references to the
</span><span class="athl-line" data-athl-line="825">// pointer. The object gets destroyed when the last
</span><span class="athl-line" data-athl-line="826">// reference to the object gets destroyed.
</span><span class="athl-line" data-athl-line="827">
</span><span class="athl-line" data-athl-line="828">// Usage of &quot;std::shared_ptr&quot;:
</span><span class="athl-line" data-athl-line="829">void foo()
</span><span class="athl-line" data-athl-line="830">{
</span><span class="athl-line" data-athl-line="831">    // It&#39;s no longer necessary to delete the Dog.
</span><span class="athl-line" data-athl-line="832">    std::shared_ptr&lt;Dog&gt; doggo(<span style="color: #ca9ee6;">new</span> Dog());
</span><span class="athl-line" data-athl-line="833">    doggo-&gt;bark();
</span><span class="athl-line" data-athl-line="834">}
</span><span class="athl-line" data-athl-line="835">
</span><span class="athl-line" data-athl-line="836">// Beware of possible circular references!!!
</span><span class="athl-line" data-athl-line="837">// There will be always a reference, so it will be never destroyed!
</span><span class="athl-line" data-athl-line="838">std::shared_ptr&lt;Dog&gt; doggo_one(<span style="color: #ca9ee6;">new</span> Dog());
</span><span class="athl-line" data-athl-line="839">std::shared_ptr&lt;Dog&gt; doggo_two(<span style="color: #ca9ee6;">new</span> Dog());
</span><span class="athl-line" data-athl-line="840">doggo_one = doggo_two; // p1 references p2
</span><span class="athl-line" data-athl-line="841">doggo_two = doggo_one; // p2 references p1
</span><span class="athl-line" data-athl-line="842">
</span><span class="athl-line" data-athl-line="843">// There are several kinds of smart pointers.
</span><span class="athl-line" data-athl-line="844">// The way you have to use them is always the same.
</span><span class="athl-line" data-athl-line="845">// This leads us to the question: when should we use each kind of smart pointer?
</span><span class="athl-line" data-athl-line="846">// std::unique_ptr - use it when you just want to hold one reference to
</span><span class="athl-line" data-athl-line="847">// the object.
</span><span class="athl-line" data-athl-line="848">// std::shared_ptr - use it when you want to hold multiple references to the
</span><span class="athl-line" data-athl-line="849">// same object and want to make sure that it&#39;s deallocated
</span><span class="athl-line" data-athl-line="850">// when all references are gone.
</span><span class="athl-line" data-athl-line="851">// std::weak_ptr - use it when you want to access
</span><span class="athl-line" data-athl-line="852">// the underlying object of a std::shared_ptr without causing that object to stay allocated.
</span><span class="athl-line" data-athl-line="853">// Weak pointers are used to prevent circular referencing.
</span><span class="athl-line" data-athl-line="854">
</span><span class="athl-line" data-athl-line="855">
</span><span class="athl-line" data-athl-line="856">/////////////////////
</span><span class="athl-line" data-athl-line="857">// Containers
</span><span class="athl-line" data-athl-line="858">/////////////////////
</span><span class="athl-line" data-athl-line="859">
</span><span class="athl-line" data-athl-line="860">// Containers or the Standard Template Library are some predefined templates.
</span><span class="athl-line" data-athl-line="861">// They manage the storage space for its elements and provide
</span><span class="athl-line" data-athl-line="862">// member functions to access and manipulate them.
</span><span class="athl-line" data-athl-line="863">
</span><span class="athl-line" data-athl-line="864">// Few containers are as follows:
</span><span class="athl-line" data-athl-line="865">
</span><span class="athl-line" data-athl-line="866">// Vector (Dynamic array)
</span><span class="athl-line" data-athl-line="867">// Allow us to Define the Array or list of objects at run time
</span><span class="athl-line" data-athl-line="868">#include &lt;vector&gt;
</span><span class="athl-line" data-athl-line="869">std::string val;
</span><span class="athl-line" data-athl-line="870">std::vector&lt;string&gt; my_vector; // initialize the vector
</span><span class="athl-line" data-athl-line="871">std::cin &gt;&gt; val;
</span><span class="athl-line" data-athl-line="872">
</span><span class="athl-line" data-athl-line="873">my_vector.push_back(val); // will push the value of &#39;val&#39; into vector (&quot;array&quot;) my_vector
</span><span class="athl-line" data-athl-line="874">my_vector.push_back(val); // will push the value into the vector again (now having two elements)
</span><span class="athl-line" data-athl-line="875">
</span><span class="athl-line" data-athl-line="876">// To iterate through a vector we have 2 choices:
</span><span class="athl-line" data-athl-line="877">// Either classic looping (iterating through the vector from index 0 to its last index):
</span><span class="athl-line" data-athl-line="878">for (int i = 0; i &lt; my_vector.size(); i++) {
</span><span class="athl-line" data-athl-line="879">    std::cout &lt;&lt; my_vector[i] &lt;&lt; &#39;\n&#39;; // for accessing a vector&#39;s element we can use the operator []
</span><span class="athl-line" data-athl-line="880">}
</span><span class="athl-line" data-athl-line="881">
</span><span class="athl-line" data-athl-line="882">// or using an iterator:
</span><span class="athl-line" data-athl-line="883">vector&lt;string&gt;::iterator it; // initialize the iterator for vector
</span><span class="athl-line" data-athl-line="884">for (it = my_vector.begin(); it != my_vector.end(); ++it) {
</span><span class="athl-line" data-athl-line="885">    std::cout &lt;&lt; *it  &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="886">}
</span><span class="athl-line" data-athl-line="887">
</span><span class="athl-line" data-athl-line="888">// Set
</span><span class="athl-line" data-athl-line="889">// Sets are containers that store unique elements following a specific order.
</span><span class="athl-line" data-athl-line="890">// Set is a very useful container to store unique values in sorted order
</span><span class="athl-line" data-athl-line="891">// without any other functions or code.
</span><span class="athl-line" data-athl-line="892">
</span><span class="athl-line" data-athl-line="893">#include&lt;set&gt;
</span><span class="athl-line" data-athl-line="894">std::set&lt;int&gt; ST;    // Will initialize the set of int data type
</span><span class="athl-line" data-athl-line="895">ST.insert(30);  // Will insert the value 30 in set ST
</span><span class="athl-line" data-athl-line="896">ST.insert(10);  // Will insert the value 10 in set ST
</span><span class="athl-line" data-athl-line="897">ST.insert(20);  // Will insert the value 20 in set ST
</span><span class="athl-line" data-athl-line="898">ST.insert(30);  // Will insert the value 30 in set ST
</span><span class="athl-line" data-athl-line="899">// Now elements of sets are as follows
</span><span class="athl-line" data-athl-line="900">//  10 20 30
</span><span class="athl-line" data-athl-line="901">
</span><span class="athl-line" data-athl-line="902">// To erase an element
</span><span class="athl-line" data-athl-line="903">ST.erase(20);  // Will erase element with value 20
</span><span class="athl-line" data-athl-line="904">// Set ST: 10 30
</span><span class="athl-line" data-athl-line="905">// To iterate through Set we use iterators
</span><span class="athl-line" data-athl-line="906">std::set&lt;int&gt;::iterator it;
</span><span class="athl-line" data-athl-line="907">for (it = ST.begin(); it != ST.end(); it++) {
</span><span class="athl-line" data-athl-line="908">    std::cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="909">}
</span><span class="athl-line" data-athl-line="910">// Output:
</span><span class="athl-line" data-athl-line="911">// 10
</span><span class="athl-line" data-athl-line="912">// 30
</span><span class="athl-line" data-athl-line="913">
</span><span class="athl-line" data-athl-line="914">// To clear the complete container we use Container_name.clear()
</span><span class="athl-line" data-athl-line="915">ST.clear();
</span><span class="athl-line" data-athl-line="916">std::cout &lt;&lt; ST.size();  // will print the size of set ST
</span><span class="athl-line" data-athl-line="917">// Output: 0
</span><span class="athl-line" data-athl-line="918">
</span><span class="athl-line" data-athl-line="919">// NOTE: for duplicate elements we can use multiset
</span><span class="athl-line" data-athl-line="920">// NOTE: For hash sets, use unordered_set. They are more efficient but
</span><span class="athl-line" data-athl-line="921">// do not preserve order. unordered_set is available since C++11
</span><span class="athl-line" data-athl-line="922">
</span><span class="athl-line" data-athl-line="923">// Map
</span><span class="athl-line" data-athl-line="924">// Maps store elements formed by a combination of a key value
</span><span class="athl-line" data-athl-line="925">// and a mapped value, following a specific order.
</span><span class="athl-line" data-athl-line="926">
</span><span class="athl-line" data-athl-line="927">#include&lt;map&gt;
</span><span class="athl-line" data-athl-line="928">std::map&lt;char, int&gt; mymap;  // Will initialize the map with key as char and value as int
</span><span class="athl-line" data-athl-line="929">
</span><span class="athl-line" data-athl-line="930">mymap.insert(<span style="color: #8caaee;">pair</span>&lt;char,int&gt;(&#39;A&#39;,1));
</span><span class="athl-line" data-athl-line="931">// Will insert value 1 for key A
</span><span class="athl-line" data-athl-line="932">mymap.insert(<span style="color: #8caaee;">pair</span>&lt;char,int&gt;(&#39;Z&#39;,26));
</span><span class="athl-line" data-athl-line="933">// Will insert value 26 for key Z
</span><span class="athl-line" data-athl-line="934">
</span><span class="athl-line" data-athl-line="935">// To iterate
</span><span class="athl-line" data-athl-line="936">std::map&lt;char,int&gt;::iterator it;
</span><span class="athl-line" data-athl-line="937">for (it = mymap.begin(); it != mymap.end(); ++it)
</span><span class="athl-line" data-athl-line="938">    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;
</span><span class="athl-line" data-athl-line="939">// Output:
</span><span class="athl-line" data-athl-line="940">// A-&gt;1
</span><span class="athl-line" data-athl-line="941">// Z-&gt;26
</span><span class="athl-line" data-athl-line="942">
</span><span class="athl-line" data-athl-line="943">// To find the value corresponding to a key
</span><span class="athl-line" data-athl-line="944">it = mymap.find(&#39;Z&#39;);
</span><span class="athl-line" data-athl-line="945">std::cout &lt;&lt; it-&gt;second;
</span><span class="athl-line" data-athl-line="946">
</span><span class="athl-line" data-athl-line="947">// Output: 26
</span><span class="athl-line" data-athl-line="948">
</span><span class="athl-line" data-athl-line="949">// NOTE: For hash maps, use unordered_map. They are more efficient but do
</span><span class="athl-line" data-athl-line="950">// not preserve order. unordered_map is available since C++11.
</span><span class="athl-line" data-athl-line="951">
</span><span class="athl-line" data-athl-line="952">// Containers with object keys of non-primitive values (custom classes) require
</span><span class="athl-line" data-athl-line="953">// compare function in the object itself or as a function pointer. Primitives
</span><span class="athl-line" data-athl-line="954">// have default comparators, but you can override it.
</span><span class="athl-line" data-athl-line="955"><span style="color: #ca9ee6;">class</span> Foo {
</span><span class="athl-line" data-athl-line="956"><span style="color: #ca9ee6;">public</span>:
</span><span class="athl-line" data-athl-line="957">    int j;
</span><span class="athl-line" data-athl-line="958">    Foo(int a) : j(a) {}
</span><span class="athl-line" data-athl-line="959">};
</span><span class="athl-line" data-athl-line="960">struct compareFunction {
</span><span class="athl-line" data-athl-line="961">    bool operator()(const Foo&amp; a, const Foo&amp; b) const {
</span><span class="athl-line" data-athl-line="962">        return a.j &lt; b.j;
</span><span class="athl-line" data-athl-line="963">    }
</span><span class="athl-line" data-athl-line="964">};
</span><span class="athl-line" data-athl-line="965">// this isn&#39;t allowed (although it can vary depending on compiler)
</span><span class="athl-line" data-athl-line="966">// std::map&lt;Foo, int&gt; fooMap;
</span><span class="athl-line" data-athl-line="967">std::map&lt;Foo, int, compareFunction&gt; fooMap;
</span><span class="athl-line" data-athl-line="968">fooMap[Foo(1)]  = 1;
</span><span class="athl-line" data-athl-line="969">fooMap.find(Foo(1)); //true
</span><span class="athl-line" data-athl-line="970">
</span><span class="athl-line" data-athl-line="971">
</span><span class="athl-line" data-athl-line="972">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="973">// Lambda Expressions (C++11 and above)
</span><span class="athl-line" data-athl-line="974">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="975">
</span><span class="athl-line" data-athl-line="976">// lambdas are a convenient way of defining an anonymous function
</span><span class="athl-line" data-athl-line="977">// object right at the location where it is invoked or passed as
</span><span class="athl-line" data-athl-line="978">// an argument to a function.
</span><span class="athl-line" data-athl-line="979">
</span><span class="athl-line" data-athl-line="980">// For example, consider sorting a vector of pairs using the second
</span><span class="athl-line" data-athl-line="981">// value of the pair
</span><span class="athl-line" data-athl-line="982">
</span><span class="athl-line" data-athl-line="983">std::vector&lt;pair&lt;int, int&gt; &gt; tester;
</span><span class="athl-line" data-athl-line="984">tester.push_back(make_pair(3, 6));
</span><span class="athl-line" data-athl-line="985">tester.push_back(make_pair(1, 9));
</span><span class="athl-line" data-athl-line="986">tester.push_back(make_pair(5, 0));
</span><span class="athl-line" data-athl-line="987">
</span><span class="athl-line" data-athl-line="988">// Pass a lambda expression as third argument to the sort function
</span><span class="athl-line" data-athl-line="989">// sort is from the &lt;algorithm&gt; header
</span><span class="athl-line" data-athl-line="990">
</span><span class="athl-line" data-athl-line="991">std::<span style="color: #8caaee;">sort</span>(tester.begin(), tester.end(), [](const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) {
</span><span class="athl-line" data-athl-line="992">        return lhs.second &lt; rhs.second;
</span><span class="athl-line" data-athl-line="993">    });
</span><span class="athl-line" data-athl-line="994">
</span><span class="athl-line" data-athl-line="995">// Notice the syntax of the lambda expression,
</span><span class="athl-line" data-athl-line="996">// [] in the lambda is used to &quot;capture&quot; variables
</span><span class="athl-line" data-athl-line="997">// The &quot;Capture List&quot; defines what from the outside of the lambda should be available inside the function body and how.
</span><span class="athl-line" data-athl-line="998">// It can be either:
</span><span class="athl-line" data-athl-line="999">//     1. a value : [x]
</span><span class="athl-line" data-athl-line="1000">//     2. a reference : [&amp;x]
</span><span class="athl-line" data-athl-line="1001">//     3. any variable currently in scope by reference [&amp;]
</span><span class="athl-line" data-athl-line="1002">//     4. same as 3, but by value [=]
</span><span class="athl-line" data-athl-line="1003">// Example:
</span><span class="athl-line" data-athl-line="1004">
</span><span class="athl-line" data-athl-line="1005">std::vector&lt;int&gt; dog_ids;
</span><span class="athl-line" data-athl-line="1006">// number_of_dogs = 3;
</span><span class="athl-line" data-athl-line="1007">for (int i = 0; i &lt; 3; i++) {
</span><span class="athl-line" data-athl-line="1008">    dog_ids.push_back(i);
</span><span class="athl-line" data-athl-line="1009">}
</span><span class="athl-line" data-athl-line="1010">
</span><span class="athl-line" data-athl-line="1011">int weight[3] = {30, 50, 10};
</span><span class="athl-line" data-athl-line="1012">
</span><span class="athl-line" data-athl-line="1013">// Say you want to sort dog_ids according to the dogs&#39; weights
</span><span class="athl-line" data-athl-line="1014">// So dog_ids should in the end become: [2, 0, 1]
</span><span class="athl-line" data-athl-line="1015">
</span><span class="athl-line" data-athl-line="1016">// Here&#39;s where lambda expressions come in handy
</span><span class="athl-line" data-athl-line="1017">
</span><span class="athl-line" data-athl-line="1018">sort(dog_ids.begin(), dog_ids.end(), [&amp;weight](const int &amp;lhs, const int &amp;rhs) {
</span><span class="athl-line" data-athl-line="1019">        return weight[lhs] &lt; weight[rhs];
</span><span class="athl-line" data-athl-line="1020">    });
</span><span class="athl-line" data-athl-line="1021">// Note we captured &quot;weight&quot; by reference in the above example.
</span><span class="athl-line" data-athl-line="1022">// More on Lambdas in C++ : https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11
</span><span class="athl-line" data-athl-line="1023">
</span><span class="athl-line" data-athl-line="1024">///////////////////////////////
</span><span class="athl-line" data-athl-line="1025">// Range For (C++11 and above)
</span><span class="athl-line" data-athl-line="1026">///////////////////////////////
</span><span class="athl-line" data-athl-line="1027">
</span><span class="athl-line" data-athl-line="1028">// You can use a range for loop to iterate over a container
</span><span class="athl-line" data-athl-line="1029">int arr[] = {1, 10, 3};
</span><span class="athl-line" data-athl-line="1030">
</span><span class="athl-line" data-athl-line="1031">for (int elem: arr) {
</span><span class="athl-line" data-athl-line="1032">    cout &lt;&lt; elem &lt;&lt; endl;
</span><span class="athl-line" data-athl-line="1033">}
</span><span class="athl-line" data-athl-line="1034">
</span><span class="athl-line" data-athl-line="1035">// You can use &quot;auto&quot; and not worry about the type of the elements of the container
</span><span class="athl-line" data-athl-line="1036">// For example:
</span><span class="athl-line" data-athl-line="1037">
</span><span class="athl-line" data-athl-line="1038">for (<span style="color: #e5c890;">auto</span> elem: arr) {
</span><span class="athl-line" data-athl-line="1039">    // Do something with each element of arr
</span><span class="athl-line" data-athl-line="1040">}
</span><span class="athl-line" data-athl-line="1041">
</span><span class="athl-line" data-athl-line="1042">/////////////////////
</span><span class="athl-line" data-athl-line="1043">// Fun stuff
</span><span class="athl-line" data-athl-line="1044">/////////////////////
</span><span class="athl-line" data-athl-line="1045">
</span><span class="athl-line" data-athl-line="1046">// Aspects of C++ that may be surprising to newcomers (and even some veterans).
</span><span class="athl-line" data-athl-line="1047">// This section is, unfortunately, wildly incomplete; C++ is one of the easiest
</span><span class="athl-line" data-athl-line="1048">// languages with which to shoot yourself in the foot.
</span><span class="athl-line" data-athl-line="1049">
</span><span class="athl-line" data-athl-line="1050">// You can override private methods!
</span><span class="athl-line" data-athl-line="1051"><span style="color: #ca9ee6;">class</span> Foo {
</span><span class="athl-line" data-athl-line="1052">    <span style="color: #ca9ee6;">virtual</span> void <span style="color: #8caaee;">bar</span>();
</span><span class="athl-line" data-athl-line="1053">};
</span><span class="athl-line" data-athl-line="1054"><span style="color: #ca9ee6;">class</span> FooSub : <span style="color: #ca9ee6;">public</span> Foo {
</span><span class="athl-line" data-athl-line="1055">    <span style="color: #ca9ee6;">virtual</span> void <span style="color: #8caaee;">bar</span>();  // Overrides Foo::bar!
</span><span class="athl-line" data-athl-line="1056">};
</span><span class="athl-line" data-athl-line="1057">
</span><span class="athl-line" data-athl-line="1058">
</span><span class="athl-line" data-athl-line="1059">// 0 == false == NULL (most of the time)!
</span><span class="athl-line" data-athl-line="1060">bool* pt = <span style="color: #ca9ee6;">new</span> bool;
</span><span class="athl-line" data-athl-line="1061">*pt = 0; // Sets the value points by &#39;pt&#39; to false.
</span><span class="athl-line" data-athl-line="1062">pt = 0;  // Sets &#39;pt&#39; to the null pointer. Both lines compile without warnings.
</span><span class="athl-line" data-athl-line="1063">
</span><span class="athl-line" data-athl-line="1064">// nullptr is supposed to fix some of that issue:
</span><span class="athl-line" data-athl-line="1065">int* pt2 = <span style="color: #ca9ee6;">new</span> int;
</span><span class="athl-line" data-athl-line="1066">*pt2 = <span style="color: #ef9f76;">nullptr</span>; // Doesn&#39;t compile
</span><span class="athl-line" data-athl-line="1067">pt2 = <span style="color: #ef9f76;">nullptr</span>;  // Sets pt2 to null.
</span><span class="athl-line" data-athl-line="1068">
</span><span class="athl-line" data-athl-line="1069">// There is an exception made for bools.
</span><span class="athl-line" data-athl-line="1070">// This is to allow you to test for null pointers with if(!ptr),
</span><span class="athl-line" data-athl-line="1071">// but as a consequence you can assign nullptr to a bool directly!
</span><span class="athl-line" data-athl-line="1072">*pt = <span style="color: #ef9f76;">nullptr</span>;  // This still compiles, even though &#39;*pt&#39; is a bool!
</span><span class="athl-line" data-athl-line="1073">
</span><span class="athl-line" data-athl-line="1074">
</span><span class="athl-line" data-athl-line="1075">// &#39;=&#39; != &#39;=&#39; != &#39;=&#39;!
</span><span class="athl-line" data-athl-line="1076">// Calls Foo::Foo(const Foo&amp;) or some variant (see move semantics) copy
</span><span class="athl-line" data-athl-line="1077">// constructor.
</span><span class="athl-line" data-athl-line="1078">Foo f2;
</span><span class="athl-line" data-athl-line="1079">Foo f1 = f2;
</span><span class="athl-line" data-athl-line="1080">
</span><span class="athl-line" data-athl-line="1081">// Calls Foo::Foo(const Foo&amp;) or variant, but only copies the &#39;Foo&#39; part of
</span><span class="athl-line" data-athl-line="1082">// &#39;fooSub&#39;. Any extra members of &#39;fooSub&#39; are discarded. This sometimes
</span><span class="athl-line" data-athl-line="1083">// horrifying behavior is called &quot;object slicing.&quot;
</span><span class="athl-line" data-athl-line="1084">FooSub fooSub;
</span><span class="athl-line" data-athl-line="1085">Foo f1 = fooSub;
</span><span class="athl-line" data-athl-line="1086">
</span><span class="athl-line" data-athl-line="1087">// Calls Foo::operator=(Foo&amp;) or variant.
</span><span class="athl-line" data-athl-line="1088">Foo f1;
</span><span class="athl-line" data-athl-line="1089">f1 = f2;
</span><span class="athl-line" data-athl-line="1090">
</span><span class="athl-line" data-athl-line="1091">
</span><span class="athl-line" data-athl-line="1092">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="1093">// Tuples (C++11 and above)
</span><span class="athl-line" data-athl-line="1094">///////////////////////////////////////
</span><span class="athl-line" data-athl-line="1095">
</span><span class="athl-line" data-athl-line="1096">#include&lt;tuple&gt;
</span><span class="athl-line" data-athl-line="1097">
</span><span class="athl-line" data-athl-line="1098">// Conceptually, Tuples are similar to old data structures (C-like structs)
</span><span class="athl-line" data-athl-line="1099">// but instead of having named data members,
</span><span class="athl-line" data-athl-line="1100">// its elements are accessed by their order in the tuple.
</span><span class="athl-line" data-athl-line="1101">
</span><span class="athl-line" data-athl-line="1102">// We start with constructing a tuple.
</span><span class="athl-line" data-athl-line="1103">// Packing values into tuple
</span><span class="athl-line" data-athl-line="1104"><span style="color: #e5c890;">auto</span> first = make_tuple(10, &#39;A&#39;);
</span><span class="athl-line" data-athl-line="1105">const int maxN = 1e9;
</span><span class="athl-line" data-athl-line="1106">const int maxL = 15;
</span><span class="athl-line" data-athl-line="1107"><span style="color: #e5c890;">auto</span> second = make_tuple(maxN, maxL);
</span><span class="athl-line" data-athl-line="1108">
</span><span class="athl-line" data-athl-line="1109">// Printing elements of &#39;first&#39; tuple
</span><span class="athl-line" data-athl-line="1110">std::cout &lt;&lt; <span style="color: #8caaee;">get</span>&lt;0&gt;(first) &lt;&lt; &quot; &quot; &lt;&lt; <span style="color: #8caaee;">get</span>&lt;1&gt;(first) &lt;&lt; &#39;\n&#39;; //prints : 10 A
</span><span class="athl-line" data-athl-line="1111">
</span><span class="athl-line" data-athl-line="1112">// Printing elements of &#39;second&#39; tuple
</span><span class="athl-line" data-athl-line="1113">std::cout &lt;&lt; <span style="color: #8caaee;">get</span>&lt;0&gt;(second) &lt;&lt; &quot; &quot; &lt;&lt; <span style="color: #8caaee;">get</span>&lt;1&gt;(second) &lt;&lt; &#39;\n&#39;; // prints: 1000000000 15
</span><span class="athl-line" data-athl-line="1114">
</span><span class="athl-line" data-athl-line="1115">// Unpacking tuple into variables
</span><span class="athl-line" data-athl-line="1116">
</span><span class="athl-line" data-athl-line="1117">int first_int;
</span><span class="athl-line" data-athl-line="1118">char first_char;
</span><span class="athl-line" data-athl-line="1119">tie(first_int, first_char) = first;
</span><span class="athl-line" data-athl-line="1120">std::cout &lt;&lt; first_int &lt;&lt; &quot; &quot; &lt;&lt; first_char &lt;&lt; &#39;\n&#39;;  // prints : 10 A
</span><span class="athl-line" data-athl-line="1121">
</span><span class="athl-line" data-athl-line="1122">// We can also create tuple like this.
</span><span class="athl-line" data-athl-line="1123">
</span><span class="athl-line" data-athl-line="1124">tuple&lt;int, char, double&gt; third(11, &#39;A&#39;, 3.14141);
</span><span class="athl-line" data-athl-line="1125">// tuple_size returns number of elements in a tuple (as a constexpr)
</span><span class="athl-line" data-athl-line="1126">
</span><span class="athl-line" data-athl-line="1127">std::cout &lt;&lt; tuple_size&lt;decltype(third)&gt;::value &lt;&lt; &#39;\n&#39;; // prints: 3
</span><span class="athl-line" data-athl-line="1128">
</span><span class="athl-line" data-athl-line="1129">// tuple_cat concatenates the elements of all the tuples in the same order.
</span><span class="athl-line" data-athl-line="1130">
</span><span class="athl-line" data-athl-line="1131"><span style="color: #e5c890;">auto</span> concatenated_tuple = tuple_cat(first, second, third);
</span><span class="athl-line" data-athl-line="1132">// concatenated_tuple becomes = (10, &#39;A&#39;, 1e9, 15, 11, &#39;A&#39;, 3.14141)
</span><span class="athl-line" data-athl-line="1133">
</span><span class="athl-line" data-athl-line="1134">std::cout &lt;&lt; <span style="color: #8caaee;">get</span>&lt;0&gt;(concatenated_tuple) &lt;&lt; &#39;\n&#39;; // prints: 10
</span><span class="athl-line" data-athl-line="1135">std::cout &lt;&lt; <span style="color: #8caaee;">get</span>&lt;3&gt;(concatenated_tuple) &lt;&lt; &#39;\n&#39;; // prints: 15
</span><span class="athl-line" data-athl-line="1136">std::cout &lt;&lt; <span style="color: #8caaee;">get</span>&lt;5&gt;(concatenated_tuple) &lt;&lt; &#39;\n&#39;; // prints: &#39;A&#39;
</span><span class="athl-line" data-athl-line="1137">
</span><span class="athl-line" data-athl-line="1138">
</span><span class="athl-line" data-athl-line="1139">///////////////////////////////////
</span><span class="athl-line" data-athl-line="1140">// Logical and Bitwise operators
</span><span class="athl-line" data-athl-line="1141">//////////////////////////////////
</span><span class="athl-line" data-athl-line="1142">
</span><span class="athl-line" data-athl-line="1143">// Most of the operators in C++ are same as in other languages
</span><span class="athl-line" data-athl-line="1144">
</span><span class="athl-line" data-athl-line="1145">// Logical operators
</span><span class="athl-line" data-athl-line="1146">
</span><span class="athl-line" data-athl-line="1147">// C++ uses Short-circuit evaluation for boolean expressions, i.e, the second argument is executed or
</span><span class="athl-line" data-athl-line="1148">// evaluated only if the first argument does not suffice to determine the value of the expression
</span><span class="athl-line" data-athl-line="1149">
</span><span class="athl-line" data-athl-line="1150">true &amp;&amp; false // Performs **logical and** to yield false
</span><span class="athl-line" data-athl-line="1151">true || false // Performs **logical or** to yield true
</span><span class="athl-line" data-athl-line="1152">! true        // Performs **logical not** to yield false
</span><span class="athl-line" data-athl-line="1153">
</span><span class="athl-line" data-athl-line="1154">// Instead of using symbols equivalent keywords can be used
</span><span class="athl-line" data-athl-line="1155">true and false // Performs **logical and** to yield false
</span><span class="athl-line" data-athl-line="1156">true or false  // Performs **logical or** to yield true
</span><span class="athl-line" data-athl-line="1157">not true       // Performs **logical not** to yield false
</span><span class="athl-line" data-athl-line="1158">
</span><span class="athl-line" data-athl-line="1159">// Bitwise operators
</span><span class="athl-line" data-athl-line="1160">
</span><span class="athl-line" data-athl-line="1161">// **&lt;&lt;** Left Shift Operator
</span><span class="athl-line" data-athl-line="1162">// &lt;&lt; shifts bits to the left
</span><span class="athl-line" data-athl-line="1163">4 &lt;&lt; 1 // Shifts bits of 4 to left by 1 to give 8
</span><span class="athl-line" data-athl-line="1164">// x &lt;&lt; n can be thought as x * 2^n
</span><span class="athl-line" data-athl-line="1165">
</span><span class="athl-line" data-athl-line="1166">
</span><span class="athl-line" data-athl-line="1167">// **&gt;&gt;** Right Shift Operator
</span><span class="athl-line" data-athl-line="1168">// &gt;&gt; shifts bits to the right
</span><span class="athl-line" data-athl-line="1169">4 &gt;&gt; 1 // Shifts bits of 4 to right by 1 to give 2
</span><span class="athl-line" data-athl-line="1170">// x &gt;&gt; n can be thought as x / 2^n
</span><span class="athl-line" data-athl-line="1171">
</span><span class="athl-line" data-athl-line="1172">~4    // Performs a bitwise not
</span><span class="athl-line" data-athl-line="1173">4 | 3 // Performs bitwise or
</span><span class="athl-line" data-athl-line="1174">4 &amp; 3 // Performs bitwise and
</span><span class="athl-line" data-athl-line="1175">4 ^ 3 // Performs bitwise xor
</span><span class="athl-line" data-athl-line="1176">
</span><span class="athl-line" data-athl-line="1177">// Equivalent keywords are
</span><span class="athl-line" data-athl-line="1178">compl 4    // Performs a bitwise not
</span><span class="athl-line" data-athl-line="1179">4 bitor 3  // Performs bitwise or
</span><span class="athl-line" data-athl-line="1180">4 bitand 3 // Performs bitwise and
</span><span class="athl-line" data-athl-line="1181">4 xor 3    // Performs bitwise xor
</span></code></pre>
</body>
</html>